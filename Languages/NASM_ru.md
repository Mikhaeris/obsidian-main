# Система регистров

Типы регистров:
- сегментные регистры
- регистры общего назначения
- специальные регистры

### Сегментные регистры
Сегментные регистры в "плоской" модели памяти не используются.

| CS  | DS  | SS  | ES  | GS  | FS  | 
| --- | --- | --- | --- | --- | --- |

### Регистры общего назначения
#### 32-bit:

| EAX | EBX | ECX | EDX | ESI | EDI | EBP | ESP |
| --- | --- | --- | --- | --- | --- | --- | --- |

#### 16-bit:  
В каждом 32-битном регистре выделяется обособленная младшая половина (младшие 16 бит), имеющая отдельные названия, получаемые отбрасыванием буквы E; иначе говоря, мы можем работать также с 16-битными регистрами AX, BX, CX, DX, SI, DI, BP и SP, которые представляют собой младшие половины соответствующих 32-битных регистров.

| AX  | BX  | CX  | DX  | SI  | DI  | BP  | SP  | 
| --- | --- | --- | --- | --- | --- | --- | --- |

#### 8-bit:
Регистры AX, BX, CS и DX также делятся на младшие и старшие части, теперь уже восьмибитные. Остальные регистры общего назначения таких обособленных однобайтовых подрегистров не имеют.

| AH  | BH  | CH  | DH  |
| --- | --- | --- | --- |
| AL  | BL  | CL  | DL  | 

#### Названия регистров:
- AX - accumulator
- BX - base
- CX - counter
- DX - data
- SI - source index
- DI - destination index
- BP - base pointer
- SP - stack pointer

### Специальные регистры
- EIP - instruction pointer
- FLAGS - flag register

#### Флаговый регистр
- ZF - zero flag
- CF - carry flag
- SF - sign flag
- OF - overflow flag
- DF - direction flag
- PF - parity flag
- AF - auxiliary carry flag
- IF - interrupt flag
- TF - trap flag

## Таблица регистров:

| 64-bit register | 32-bit sub-register | 16-bit sub-register | 8-bit sub-register |
| --------------- | ------------------- | ------------------- | ------------------ |
| rax             | eax                 | ax                  | al                 |
| rbx             | ebx                 | bx                  | bl                 |
| rcx             | ecx                 | cx                  | cl                 |
| rdx             | edx                 | dx                  | dl                 |
| rsi             | esi                 | si                  | sil                |
| rdi             | edi                 | di                  | dil                |
| rbp             | ebp                 | bp                  | bpl                |
| rsp             | esp                 | sp                  | spl                |
| r8              | r8d                 | r8w                 | r8b                |
| r9              | r9d                 | r9w                 | r9b                |
| r10             | r10d                | r10w                | r10b               |
| r11             | r11d                | r11w                | r11b               |
| r12             | r12d                | r12w                | r12b               |
| r13             | r13d                | r13w                | r13b               |
| r14             | r14d                | r14w                | r14b               |
| r15             | r15d                | r15w                | r15b               |

32-bit:
![[Pasted image 20260127141223.png]]

# Сегменты
Три основных сегмента:
- сегмент кода(.text)
- сегмент данных
	- секция инициализированных данных(.data)
	- секция неинициализированных данных(.bss)
- сегмент стека

![[Pasted image 20260127144944.png]]

# Директивы для отведения памяти
Ассемблер осуществляет трансляцию мнемоник команд в бинарный код, формируя массив данных, который в дальнейшем интерпретируется центральным процессором (ЦП) как последовательность инструкций. Управление программой реализуется путем загрузки адреса точки входа в регистр указателя команд.

### Структура сегмента памяти
Для организации данных и кода внутри программы используются специализированные разделы, объявляемые с помощью директивы section:
- **.text**: Содержит исполняемый машинный код.
- **.data**: Предназначена для инициализированных данных, значения которых определяются на этапе компиляции и включаются в образ исполняемого файла.
- **.bss**: Резервирует пространство для неинициализированных переменных. В объектном файле сохраняется только информация о требуемом размере данного раздела, что позволяет оптимизировать объем файла на диске.

### Директивы управления памятью
Ассемблер (в частности, NASM) предоставляет средства распределения памяти на основе стандартных единиц данных:

| Тип данных         | Размер(байты) | Директива (Data/BSS) |
| ------------------ | ------------- | -------------------- |
| Байт               | 1             | db/resb              |
| Слово              | 2             | dw/resw              |
| Двойное слово      | 4             | dd/resd              |
| Учетверенное слово | 8             | dq/resq              |

#### Директивы резервирования неинициализированной памяти
Эти директивы приказывают ассемблеру выделить заданное количество ячеек памяти, причем ничего, кроме количества, не уточняется.
- `resb`
- `resw`
- `resd`
- `resq`

Обычно перед директивой резервирования памяти ставится метка.  
Пример:
```nasm
string resb 20
count  resw 256
x      resd 1
```

#### Директивы задания исходных данных
Эти директивы не просто резервируют память, а указывают, какие значения в этой памяти должны находиться к моменту запуска программы. Соответствующие значение указывается после директивы через запятую; памяти отводится столько, сколько указано значений.
- `db`
- `dw`
- `dd`
- `dq`

Пример:
```nasm
fibon dw 1, 1, 2, 3, 5, 8, 13, 21
```

# Задание числовых значений
Числовые значения могут быть заданы в:
- двоичной
- восьмиричной
- десятичной
- шестнадцатиричной

#### Двоичная
Двоичное число обозначается буквой **b** на конце.
```nasm
10011011b
```

#### Восьмиричная
Восьмиричное число обозначается добавлением после числа буквы **o** или **q** в конце числа. 
```nasm
634o
754q
```

#### Десятичная
Десятичное число обозначается в стандартной математической форме.
```nasm
2026
```

#### Шестандцатиричная
Шестнадцатиричное число может быть задано тремя сособами:
- Добавление буквы **h** на конец слова
	- Если число начинается с буквы, то цифра *0* должна быть поставлена в конце числа
- Добавлением символа **$** в начало числа
	- Если число начинается с буквы, то цифра *0* должна быть добавлена в начало числа
- Добавлением перед числом символов **0x**

Пример:
```nasm
2af3h
0a21h

$2af3
$0f9

0x2af3
```

# Текстовые строки
Ассемблер позволяет вместо кода написать сам символ, взяв его в апострофы или двойные кавычки.
```nasm
dig7 db '7'
welmsg db 'Welcome to Cyberspace!'
```
Внутри двойных кавычек апострофы рассматриваются как обычный символ; то же самое можно сказать и о символе двойных кавычек внутри апострофов.
```nasm
panic db 'So I say: "Don', "'", 't panic"'
```

# Команды
### Команда `mov`
Команда `mov` имеет два операнда:
1) Первый операнд задает то место, куда будут помещены данные.
2) Второй операнд то, откуда данные будут взяты.

```nasm
mov eax, ebx
```
Команда `mov` только копирует данные, не выполняя никаких преобразований. Для преобразований данных существуют другие команды.

### Виды операндов
Есть три вида операндов:
1) **Непосредственный операнд**
	```nasm
	mov edx, 40f2a008h
	```
2) **Регистровый операнд**
	```nasm
	mov eax, ebx
	```
3) **Адресный операнд / операнд типа "память"** 
	```nasm
	section .data
	count dd 0
	
	section .text
	    mov [count], eax
	```

### Косвенная адресация
Пример:
```nasm
mov ebx, [eax]
```
Это означает: "Возьми значение в регистре EAX, используй это значение в качестве адреса, по этому адресу обратись к памяти, возьми оттуда четыре байты и занеси их в регистр EBX."
В противоположность:
```nasm
mov ebx, eax
```
Это означает: "Скопируй содержимое регистра EAX в регистр EBX."

### Исполнительный адрес
Адрес, по которому очередная машинная команда произведет обращение к памяти (неважно, задан этот адрес явно или вычислен) называется **исполнительным адресом**.
Процессор позволяет задать исполнительный адрес так, чтобы он вычислял *уже в ходе выполнения команды*.

Общий вид исполнительного адреса:
![[Pasted image 20260127171352.png]]

Каждое из трех слагаемых, используемых в исполнительном адресе, является необязательным.

#### Команда `lea`
Команда `lea`использует возможности процессора по вычислению исполнительно адреса без обращения к памяти . Команда имеется два операнда: первый обязан быть регистровым, а второй операндом типа "память".
```nasm
lea eax, [1000+ebx+8*ecx]
```

### Размеры операндов и их допустимые значения
Допустимые комбинации типов операндов для команды `mov`:
- в регистр из регистра
- в память из регистра
- в регистр из памяти
- в регистр из непосредственного операнда (т.е. из кода команды)
- в ячейку или область памяти из непосредственного операнда


```nasm
mov [x], 25 ; ОШИБКА!!!
```
Чтобы воспользоваться такой командой, нужно объяснить ассемблеру, что конкретно имеется в виду, поставив перед любым из операндов спецификатор размера.
- byte
- word
- dword
- qword
```nasm
mov dword [x], 25
```

### Целочисленное сложение и вычитание
#### Команды `add` и `sub`
Операции сложения и вычитания над целыми числами производятся соответственно командами `add` и `sub`.
Обе инструкции имеют два операнда:
- Первый из них задает и одно из чисел, участвующих в операции, и место, куда следует записать результат
- Второй задает второе число для операции(второе слагаемое, либо вычитаемое)

Для этих команд возможны те же пять форм допустимых комбинаций типов операндов, что и для команды `mov`.
```nasm
add eax, ebx

sub [x], ecx
```
Сложение и вычитание знаковых и беззнаковых чисел с точки зрения реализации выполняется абсолютно одинаково, так что при сложении и вычитании процессор может не знать (и не знает), со знаковым или беззнаковыми числами он работает.

В соответствии с полученным результатом команды `add` и `sub` выставляют значения флагов OF, CF, ZF, и SF.

1) Флаг ZF устанавливается, если в результате последней операции получился ноль, в противном случае флаг сбрасывается.
2) Флаг SF устанавливается, если получено отрицательное число, иначе он сбрасывается (имеет смысл только для знаковых чисел).
3) Флаг OF устанавливается, если произошло переполнение, что означает, что знак полученного результата не соответствует тому, который должен был получится исходя из математического смысла операции (имеет смысл только для знаковых чисел).
4) Флаг CF устанавливается, если произошел перенос из старшего разряда, либо произошел заем из несуществующего разряда. (имеет смысл только для беззнаковых чисел).

#### Команды `adc` и `sbb`
Сложение и вычитание с учетом переноса выполняются инструкциями `adc` и `sbb`, которые учитывают значение флага переноса CF.

Предположим у нас есть два 64-битных целых числа, причем первое записано в регистры EDX (старшие 32 бита) и EAX (младшие 32 бита), а второе точно так же записано в регистры EBX и EAX.  
Тогда сложить эти два числа можно:
```nasm
add eax, ecx    ; складываем младшие части
adc edx, ebx    ; теперь старшие, с учетом переноса
```
Если же нам понадобится вычитание, то это делается командами:
```nasm
sub eax, ecx    ; вычитаем младшие части
sbb edx, ebx    ; теперь старшие, с учетом займа
```

#### Команды `inc` и `dec`
Команды `inc` и `dec` имеют один операнд (регистровый или типа "память") и производят соответственно увеличение и уменьшение на единицу. Обе команды устанавливают флаги ZF, OF и SF, но не затрагивают флаг CF.
```nasm
mov eax, 0

inc eax       ; теперь в eax хранится 1
dec eax       ; теперь в eax хранится 0
```

#### Команда `neg`
Команда `neg`, также имеющая один операнд, обозначает смену знака, то есть операцию "унарный минус". Обычно ее применяют к знаковым числам; тем не менее она устанвливает все четыре флага ZF, OF и SF и CF.
```nasm
neg eax
```

#### Команда `cmp`
Команда `cmp` производит точно такое же вычитание, как и команда `sub`, за исключением того, что результат никуда не записывается. Команда вызывается ради установки флагов, обычно сразу поле нее следует команда условного перехода. Первый операнд команды `cmp`  не может быть непосредственным(потому что команда `sub` не модет работать с непосредственным операндом).
```nasm
cmp eax, 10
je  some_label
```

### Целочисленное умножение и деление
Все команды целочисленного умножения и деления имеют только один операнд(но есть некоторые исключения), задающий второй множитель в командах умножения и делитель в командах деления, причем этот операнд может быть регистровым или типа "память", но не непосредственным. В роли первого множителя и делимого, а также места для записи результата используется **неявный операнд**, в качестве которого выступают регистры AL, AX, EAX, а при необходимости - и регистровые пары DX:AX и EDX:EAX.

#### Команды `mul` и `imul`
Для умножения беззнаковых чисел применяют команду `mul`, для умножения знаковых команду `imul`. В обоих случаях в зависимости от разрядности операнда (второго множителя) первый берется из соответствующего по разрядности регистра.

| разрдность (бит) | неявный множитель | результат умножения | 
| ---------------- | ----------------- | ------------------- |
| 8                | AL                | AX                  |
| 16               | AX                | DX:AX               |
| 32               | EAX               | EDX:EAX             |

```nasm
mov al, 2
mov bl, 3

mul bl       ; теперь ax хранит 6
```

Команды `mul` и `imul` сбрасывают флаги CF и OF, если старшая половина результата фактически не используется, то есть все значащие биты результата уместились в младшей половине. Для `mul` это означает, что все разряды старшей половины результата содержат нули, для `imul` что все разряды старшей половины результата равны старшему биту младшей половины половины результата. В противном случае CF и OF устанавливаются.
Значения остальных регистров после выполнения `mul` и `imul` не определены.

#### Команды `div` и `idiv`
Для деления (и нахождения остатка от деления) целых чисел применяют команду `div` (для знаковых) и `idiv` (для знаковых). Единственный операнд команды, как уже говорилось выше, задает делитель. В зависимости от разрядности этого делителя делимое берется из регистра соответствующего разряда. Частное всегда округляется в сторону нуля (для беззнаковых и положительных - в меньшую, для отрицательных - в большую сторону). Знак остатка, вычисляемого командой `idiv`, всегда совпадает со знаком делимого, а абсолютная величина (модуль) остатка всегда строго меньше модуля делителя. Значения флагов после выполнения целочисленного деления не определены.

| разрядность (бит) | делимое | частное | остаток |
| ----------------- | ------- | ------- | ------- |
| 8                 | AX      | AL      | AH      |
| 16                | DX:AX   | AX      | DX      |
| 32                | EDX:EAX | EAX     | EDX     |

```nasm
mov ax, 7
mov bx, 3

div bx       ; теперь al хранит 2, а ah хранит 1
```
Если в делителе на момент выполнения команды `div` или `idiv` находится число ноль, то процессор инициирует *исключение*, называемое также *внутренним прерыванием*, в результате которого управление получает операционная система; в большинстве случаев она сообщает об ошибке и завершает текущую задачу как аварийную. То же самое произойдет и в случае, если результат деления не уместился в отведенные ему разряды.

#### Целочисленное расширение
При выполнении целочисленного деления чисел со знаком часто требуется выполнить расширение делимого перед началом операции.

Команды:
- `cbw` (convert byte to word) - расширяет число в регистре AL до регистра AX
- `cwd` (convert word to doubleword) - расширяет число в регистре AX до регистровой пары DX:AX
- `cwde` (convert word to dword, extended) - расширяет число в регистре AX до регистра EAX
- `cdq` (convert dword to qword) - расширяет число в регистре EAX до регистровой пары EDX:EAX

При делении беззнаковых чисел специальные команды для расширения разрядности не нужны; достаточно просто обнулить старшую часть делимого, будь то AH, DX или EDX.

### Уловные и безусловные переходы
В обычное последовательное выполнение команд можно вмешаться, выполнив **передачу управления**, называемую также **переходом**; команда передачи управления принудительно записывает новый адрес в регистр EIP, заставляя процессор продолжить выполнение программы с другого места.

Есть два типа команд перехода:
- **Безусловный переход** - выполняет передачу управления в другое место программы без всяких всяких проверок.
- **Условный переход** - в зависимости от результата проверки некоторого условия либо выполняет переход в заданную точку, либо не выполняет его, в этом случае выполнение программы, как обычно, продолжится со следующей команды.

Команды передачи управления подразделяются на три типа в зависимости от "дальности" такой передачи.
- **Дальние** (`far`) переходы подразумевают управление во фрагмент программы, расположенной в другом сегменте. Поскольку под управлением OC UNIX мы используем "плоскую" модель памяти, такие переходы нам понадобиться не могут; у нас просто нет других сегментов.
- **Близкие** (`near`) переходы передают управление в произвольное место внутри одного сегмента; фактически такие переходы представляют собой явное изменение значения EIP. В "плоской" модели памяти это именно тот вид переходов, с помощью которого мы можем "прыгнуть" в произвольное место в адресном пространстве.
- **Короткие** (`short`) переходы используются для оптимизации в случае, если точку куда надлежит "прыгнуть", отстоит от текущей команды не более чем на 127 байт вперед или 128 байт назад. В машинном коде такой команды смещение задается всего одним байтом, отсюда соответственно ограничение.

Вид перехода можно указать явно, поставив после команды слово `short` или `near` (ассмеблре понимает, разумеется, и слово `far`).

#### Безусловный переход
Команда **безусловного перехода** называется `jmp`. У команды предусмотрен один операнд, определяющий собственно адрес, куда следует передать управление. Чаще всего используется форма команды `jmp` с непосредственным операндом, то есть адресом, указанным прямо в команде; естественно, указываем мы не числовой адрес, которого обычно просто не знаем, а метку.  
Также возможно использовать регистровый операнд (в этом случае переход производится по адресу, взятому из регистра) или операнд типа "память" (адрес читается из двойного слова, расположенного в заданной позиции в памяти); такие переходы называются **косвенными**, в отличие от **прямых**, для которых адрес задается явно.
```nasm
jmp cycle    ; переход на метку cycle
jmp eax      ; переход по адресу из регистра EAX
jmp [addr]   ; переход по адресу, содержащемуся
             ; в памяти которая помечена меткой addr
jmp [eax]    ; переход по адресу, прочитанному из
             ; памяти, расположенной по адресу,
             ; взятому из регистра EAX
```
Здесь первая команда задет **прямой** переход, а остальные **косвенный**.

#### Условный переход
Команды **условных переходов** процессор поддерживает довольно много: переход может выполняться в зависимости от значения одного флага, комбинации флагов и даже в зависимости от значения регистра.

Например:
```nasm
mov eax, 9
cmp eax, 10
je exit
```
Важное замечание, в противоположность командам безусловного перехода, команды условного перехода ассемблер по умолчанию считает "короткими", если не указать тип перехода явно.
Еще один нетривиальный момент состоит в том, что *все команды условных переходов допускают только непосредственный операнд*(обычно это просто метка). Ни из регистров, ни из памяти взять адрес для такого перехода нельзя.

### Построение ветвлений и циклов
Обычный паскалевский цикл с предусловием
```pascal
while <условие> do <тело>
```
средствами машинных команд реализуется по следующей схеме:
```nasm
cycle:   <вычисление условия>
         JNx cycle_quit        ; выход
         <выполенение тела>
         JMP cycle             ; повтор
cycle_quit:
```
а ветвление в его полном варианте
```pascal
if <условие> then <ветвь1> else <ветвь2>
```
превращается в:
```nasm
         <вычисление условия>
         JNx else_branch       ; на ветку else
         <выполение ветви1>
         JMP if_quit           ; обход ветки else
else_branch:
         <выполение ветки2>
if_quit:
```

### Условные переходы и регистр ECX; циклы
В системе команд процессора имеются специальные команды для построения циклов с ECX в роли счетчика, а для других регистров таких команд нет.

#### Команда `loop`
Одна из таких команд называется `loop` и предназначена для организации циклов с заранее известным количеством итераций. В качестве счетчика цикла она использует регистр ECX, в котором перед началом цикла следует занести число нужных итераций.  
Сама команда loop выполняет два действия: уменьшает на еденицу значение в регистре ECX и, если в результате значение не стало равным нулю, производит переход на заданную метку. Команда `loop` выполняет только "короткие" переходы.

Пусть, например, есть массив из 1000 двойных слов, заданный с помощью директивы:
```nasm
array resd 1000
```
Тогда посчитать сумму его элементов можно так:
```nasm
        mov ecx, 1000   ; количество итераций
        mov esi, array  ; адрес первого элемента
        mov eax, 0      ; начальное значение сумму
lp:     add eax, [esi]  ; прибавляем число к сумму
        add esi, 4      ; адрес следующего элемента
        loop lp         ; уменьшаем счетчик
                        ; если нужно - продолжаем
```

#### Команда `jecxz`
Команда `jcxz` (jump if CX is zero) производит переход, если в регистре CX содержится ноль. Флаги при этом не учитываются. Аналогичным образом команда `jecxz` производит переход, если ноль содержится в регистре ECX. Как и для команды `loop`, этот переход короткий. Они нужны на тот случай, если в ECX уже будет содержатся ноль в первой итерации цикла.
```
        ; заполняем ecx
        jecxz lpq
lp:     ; тело цикла
		; ...
		loop lp
lpq:
```

#### Модификации команды `loop`
Модификации команды `loop`:
- `loope`(или по другому`loopz`) производит переход, если в регистре после его уменьшения на еденицу - не ноль и при этом флаг ZF установлен. 
- `loopne` (или, по другому`loopnz`) - если в регистре ECX не ноль и флаг ZF сброшен.

Уменьшение регистра ECX эти команды производят в любом случае, т.е. даже тогда, когда ZF "не в том положении".

### Побитовые операции
Информацию, записанную в регистры и память в виде байтов, слов и двойных слов можно рассматривать не только как представление целых чисел, но и как строки, состоящие из отдельных и (в общем случае) никак не связанных между собой битов.

Побитовые операции:
- `and` - логическое "И"
- `or` - логическое "ИЛИ"
- `xor` - логическое "Исключающее или"
- `not` - логическое "НЕ" / побитовое отрицание (инверсия)

Выполняют соответствующие логические операцию отдельно над первым битом обоих операндов, отдельно над вторыми битами и т.д.; результат, представляющий собой битовую строку той же длины, что и операнды заносится, как обычно для арифметических команд, в регистры или облаять памяти, определяемую первым операндом.

Ограничения на используемые операнды у этих такие же, как и у двухместных арифметических команд: первый операнд должен быть либо регистровым, либо типа "память", второй операнд может быть любого типа; нельзя использовать операнд типа "память" одновременно для первого и для второго операнда; если ни один из операндов не является не является регистровым, необходимо указать разрядность операции с поощью одного из слов (`byte`, `word`, `dword`и `qword`).

#### Команда `test`
Команда `test` работает так же, как и команда `and`, то есть выполняет побитовое "и" над своими операндами, но результат никуда не записывается, а только выставляет флаги.
```nasm
test eax, eax
jz lp
```

#### Операции побитового сдвига
Работают над всеми битами сразу, попросту сдвигая их.

Команды `shr` (shift right) и `shl` (shift left) имеют два операнда, первый из которых указывает, что сдвигать, а второй на сколько битов производить сдвиг.
- Первый операнд может быть регистровым или типа "память" (во втором случае обязательно указание разрядности).
- Второй операнд может быть либо непосредственным, то есть числом от 1 до 31 (можно указать любое число, но от него будут использоваться только младшие пять разрядов), либо регистром CL; никакие другие регистры использовать нельзя.

#### Команды арифметического побитового сдвига
Для беззнаковых чисел сдвиг на n бит влево эквивалентен умножени. на 2^n 
- `sal` (shift arithmetic left) делает то же самое, что и команда `shl` (на самом деле это одна и так же машинная команда).
- `sar` (shift arithmetic right) работает аналогично команде `shr`, за исключением того, что в старшем бите значение сохраняется таким же, каким оно было до операции.
# Система регистров

Типы регистров:
- сегментные регистры
- регистры общего назначения
- специальные регистры

### Сегментные регистры
Сегментные регистры в "плоской" модели памяти не используются.

| CS  | DS  | SS  | ES  | GS  | FS  | 
| --- | --- | --- | --- | --- | --- |

### Регистры общего назначения
#### 32-bit:

| EAX | EBX | ECX | EDX | ESI | EDI | EBP | ESP |
| --- | --- | --- | --- | --- | --- | --- | --- |

#### 16-bit:  
В каждом 32-битном регистре выделяется обособленная младшая половина (младшие 16 бит), имеющая отдельные названия, получаемые отбрасыванием буквы E; иначе говоря, мы можем работать также с 16-битными регистрами AX, BX, CX, DX, SI, DI, BP и SP, которые представляют собой младшие половины соответствующих 32-битных регистров.

| AX  | BX  | CX  | DX  | SI  | DI  | BP  | SP  | 
| --- | --- | --- | --- | --- | --- | --- | --- |

#### 8-bit:
Регистры AX, BX, CS и DX также делятся на младшие и старшие части, теперь уже восьмибитные. Остальные регистры общего назначения таких обособленных однобайтовых подрегистров не имеют.

| AH  | BH  | CH  | DH  |
| --- | --- | --- | --- |
| AL  | BL  | CL  | DL  | 

#### Названия регистров:
- AX - accumulator
- BX - base
- CX - counter
- DX - data
- SI - source index
- DI - destination index
- BP - base pointer
- SP - stack pointer

### Специальные регистры
- EIP - instruction pointer
- FLAGS - flag register

#### Флаговый регистр
- ZF - zero flag
- CF - carry flag
- SF - sign flag
- OF - overflow flag
- DF - direction flag
- PF - parity flag
- AF - auxiliary carry flag
- IF - interrupt flag
- TF - trap flag

## Таблица регистров:

| 64-bit register | 32-bit sub-register | 16-bit sub-register | 8-bit sub-register |
| --------------- | ------------------- | ------------------- | ------------------ |
| rax             | eax                 | ax                  | al                 |
| rbx             | ebx                 | bx                  | bl                 |
| rcx             | ecx                 | cx                  | cl                 |
| rdx             | edx                 | dx                  | dl                 |
| rsi             | esi                 | si                  | sil                |
| rdi             | edi                 | di                  | dil                |
| rbp             | ebp                 | bp                  | bpl                |
| rsp             | esp                 | sp                  | spl                |
| r8              | r8d                 | r8w                 | r8b                |
| r9              | r9d                 | r9w                 | r9b                |
| r10             | r10d                | r10w                | r10b               |
| r11             | r11d                | r11w                | r11b               |
| r12             | r12d                | r12w                | r12b               |
| r13             | r13d                | r13w                | r13b               |
| r14             | r14d                | r14w                | r14b               |
| r15             | r15d                | r15w                | r15b               |

32-bit:
![[Pasted image 20260127141223.png]]

# Сегменты
Три основных сегмента:
- сегмент кода(.text)
- сегмент данных
	- секция инициализированных данных(.data)
	- секция неинициализированных данных(.bss)
- сегмент стека

![[Pasted image 20260127144944.png]]

# Директивы для отведения памяти
Ассемблер осуществляет трансляцию мнемоник команд в бинарный код, формируя массив данных, который в дальнейшем интерпретируется центральным процессором (ЦП) как последовательность инструкций. Управление программой реализуется путем загрузки адреса точки входа в регистр указателя команд.

### Структура сегмента памяти
Для организации данных и кода внутри программы используются специализированные разделы, объявляемые с помощью директивы section:
- **.text**: Содержит исполняемый машинный код.
- **.data**: Предназначена для инициализированных данных, значения которых определяются на этапе компиляции и включаются в образ исполняемого файла.
- **.bss**: Резервирует пространство для неинициализированных переменных. В объектном файле сохраняется только информация о требуемом размере данного раздела, что позволяет оптимизировать объем файла на диске.

### Директивы управления памятью
Ассемблер (в частности, NASM) предоставляет средства распределения памяти на основе стандартных единиц данных:

| Тип данных         | Размер(байты) | Директива (Data/BSS) |
| ------------------ | ------------- | -------------------- |
| Байт               | 1             | db/resb              |
| Слово              | 2             | dw/resw              |
| Двойное слово      | 4             | dd/resd              |
| Учетверенное слово | 8             | dq/resq              |

#### Директивы резервирования неинициализированной памяти
Эти директивы приказывают ассемблеру выделить заданное количество ячеек памяти, причем ничего, кроме количества, не уточняется.
- `resb`
- `resw`
- `resd`
- `resq`
- `rest`

Обычно перед директивой резервирования памяти ставится метка.  
Пример:
```nasm
string resb 20
count  resw 256
x      resd 1
```

#### Директивы задания исходных данных
Эти директивы не просто резервируют память, а указывают, какие значения в этой памяти должны находиться к моменту запуска программы. Соответствующие значение указывается после директивы через запятую; памяти отводится столько, сколько указано значений.
- `db`
- `dw`
- `dd`
- `dq`
- `dt`

Пример:
```nasm
fibon dw 1, 1, 2, 3, 5, 8, 13, 21
```

# Задание числовых значений
Числовые значения могут быть заданы в:
- двоичной
- восьмиричной
- десятичной
- шестнадцатиричной

#### Двоичная
Двоичное число обозначается буквой **b** на конце.
```nasm
10011011b
```

#### Восьмиричная
Восьмиричное число обозначается добавлением после числа буквы **o** или **q** в конце числа. 
```nasm
634o
754q
```

#### Десятичная
Десятичное число обозначается в стандартной математической форме.
```nasm
2026
```

#### Шестандцатиричная
Шестнадцатиричное число может быть задано тремя сособами:
- Добавление буквы **h** на конец слова
	- Если число начинается с буквы, то цифра *0* должна быть поставлена в конце числа
- Добавлением символа **$** в начало числа
	- Если число начинается с буквы, то цифра *0* должна быть добавлена в начало числа
- Добавлением перед числом символов **0x**

Пример:
```nasm
2af3h
0a21h

$2af3
$0f9

0x2af3
```

# Текстовые строки
Ассемблер позволяет вместо кода написать сам символ, взяв его в апострофы или двойные кавычки.
```nasm
dig7 db '7'
welmsg db 'Welcome to Cyberspace!'
```
Внутри двойных кавычек апострофы рассматриваются как обычный символ; то же самое можно сказать и о символе двойных кавычек внутри апострофов.
```nasm
panic db 'So I say: "Don', "'", 't panic"'
```

# Команды
### Команда `mov`
Команда `mov` имеет два операнда:
1) Первый операнд задает то место, куда будут помещены данные.
2) Второй операнд то, откуда данные будут взяты.

```nasm
mov eax, ebx
```
Команда `mov` только копирует данные, не выполняя никаких преобразований. Для преобразований данных существуют другие команды.

### Виды операндов
Есть три вида операндов:
1) **Непосредственный операнд**
	```nasm
	mov edx, 40f2a008h
	```
2) **Регистровый операнд**
	```nasm
	mov eax, ebx
	```
3) **Адресный операнд / операнд типа "память"** 
	```nasm
	section .data
	count dd 0
	
	section .text
	    mov [count], eax
	```

### Косвенная адресация
Пример:
```nasm
mov ebx, [eax]
```
Это означает: "Возьми значение в регистре EAX, используй это значение в качестве адреса, по этому адресу обратись к памяти, возьми оттуда четыре байты и занеси их в регистр EBX."
В противоположность:
```nasm
mov ebx, eax
```
Это означает: "Скопируй содержимое регистра EAX в регистр EBX."

### Исполнительный адрес
Адрес, по которому очередная машинная команда произведет обращение к памяти (неважно, задан этот адрес явно или вычислен) называется **исполнительным адресом**.
Процессор позволяет задать исполнительный адрес так, чтобы он вычислял *уже в ходе выполнения команды*.

Общий вид исполнительного адреса:
![[Pasted image 20260127171352.png]]

Каждое из трех слагаемых, используемых в исполнительном адресе, является необязательным. Но выражение в квадратных скобках никоим образом не может быть произвольным.

#### Команда `lea`
Команда `lea`использует возможности процессора по вычислению исполнительно адреса без обращения к памяти . Команда имеется два операнда: первый обязан быть регистровым, а второй операндом типа "память".
```nasm
lea eax, [1000+ebx+8*ecx]
```

### Размеры операндов и их допустимые значения
Допустимые комбинации типов операндов для команды `mov`:
- в регистр из регистра
- в память из регистра
- в регистр из памяти
- в регистр из непосредственного операнда (т.е. из кода команды)
- в ячейку или область памяти из непосредственного операнда


```nasm
mov [x], 25 ; ОШИБКА!!!
```
Чтобы воспользоваться такой командой, нужно объяснить ассемблеру, что конкретно имеется в виду, поставив перед любым из операндов спецификатор размера.
- byte
- word
- dword
- qword
```nasm
mov dword [x], 25
```

### Целочисленное сложение и вычитание
#### Команды `add` и `sub`
Операции сложения и вычитания над целыми числами производятся соответственно командами `add` и `sub`.
Обе инструкции имеют два операнда:
- Первый из них задает и одно из чисел, участвующих в операции, и место, куда следует записать результат
- Второй задает второе число для операции(второе слагаемое, либо вычитаемое)

Для этих команд возможны те же пять форм допустимых комбинаций типов операндов, что и для команды `mov`.
```nasm
add eax, ebx

sub [x], ecx
```
Сложение и вычитание знаковых и беззнаковых чисел с точки зрения реализации выполняется абсолютно одинаково, так что при сложении и вычитании процессор может не знать (и не знает), со знаковым или беззнаковыми числами он работает.

В соответствии с полученным результатом команды `add` и `sub` выставляют значения флагов OF, CF, ZF, и SF.

1) Флаг ZF устанавливается, если в результате последней операции получился ноль, в противном случае флаг сбрасывается.
2) Флаг SF устанавливается, если получено отрицательное число, иначе он сбрасывается (имеет смысл только для знаковых чисел).
3) Флаг OF устанавливается, если произошло переполнение, что означает, что знак полученного результата не соответствует тому, который должен был получится исходя из математического смысла операции (имеет смысл только для знаковых чисел).
4) Флаг CF устанавливается, если произошел перенос из старшего разряда, либо произошел заем из несуществующего разряда. (имеет смысл только для беззнаковых чисел).

#### Команды `adc` и `sbb`
Сложение и вычитание с учетом переноса выполняются инструкциями `adc` и `sbb`, которые учитывают значение флага переноса CF.

Предположим у нас есть два 64-битных целых числа, причем первое записано в регистры EDX (старшие 32 бита) и EAX (младшие 32 бита), а второе точно так же записано в регистры EBX и EAX.  
Тогда сложить эти два числа можно:
```nasm
add eax, ecx    ; складываем младшие части
adc edx, ebx    ; теперь старшие, с учетом переноса
```
Если же нам понадобится вычитание, то это делается командами:
```nasm
sub eax, ecx    ; вычитаем младшие части
sbb edx, ebx    ; теперь старшие, с учетом займа
```

#### Команды `inc` и `dec`
Команды `inc` и `dec` имеют один операнд (регистровый или типа "память") и производят соответственно увеличение и уменьшение на единицу. Обе команды устанавливают флаги ZF, OF и SF, но не затрагивают флаг CF.
```nasm
mov eax, 0

inc eax       ; теперь в eax хранится 1
dec eax       ; теперь в eax хранится 0
```

#### Команда `neg`
Команда `neg`, также имеющая один операнд, обозначает смену знака, то есть операцию "унарный минус". Обычно ее применяют к знаковым числам; тем не менее она устанвливает все четыре флага ZF, OF и SF и CF.
```nasm
neg eax
```

#### Команда `cmp`
Команда `cmp` производит точно такое же вычитание, как и команда `sub`, за исключением того, что результат никуда не записывается. Команда вызывается ради установки флагов, обычно сразу поле нее следует команда условного перехода. Первый операнд команды `cmp`  не может быть непосредственным(потому что команда `sub` не модет работать с непосредственным операндом).
```nasm
cmp eax, 10
je  some_label
```

### Целочисленное умножение и деление
Все команды целочисленного умножения и деления имеют только один операнд(но есть некоторые исключения), задающий второй множитель в командах умножения и делитель в командах деления, причем этот операнд может быть регистровым или типа "память", но не непосредственным. В роли первого множителя и делимого, а также места для записи результата используется **неявный операнд**, в качестве которого выступают регистры AL, AX, EAX, а при необходимости - и регистровые пары DX:AX и EDX:EAX.

#### Команды `mul` и `imul`
Для умножения беззнаковых чисел применяют команду `mul`, для умножения знаковых команду `imul`. В обоих случаях в зависимости от разрядности операнда (второго множителя) первый берется из соответствующего по разрядности регистра.

| разрдность (бит) | неявный множитель | результат умножения | 
| ---------------- | ----------------- | ------------------- |
| 8                | AL                | AX                  |
| 16               | AX                | DX:AX               |
| 32               | EAX               | EDX:EAX             |

```nasm
mov al, 2
mov bl, 3

mul bl       ; теперь ax хранит 6
```

Команды `mul` и `imul` сбрасывают флаги CF и OF, если старшая половина результата фактически не используется, то есть все значащие биты результата уместились в младшей половине. Для `mul` это означает, что все разряды старшей половины результата содержат нули, для `imul` что все разряды старшей половины результата равны старшему биту младшей половины половины результата. В противном случае CF и OF устанавливаются.
Значения остальных регистров после выполнения `mul` и `imul` не определены.

#### Команды `div` и `idiv`
Для деления (и нахождения остатка от деления) целых чисел применяют команду `div` (для знаковых) и `idiv` (для знаковых). Единственный операнд команды, как уже говорилось выше, задает делитель. В зависимости от разрядности этого делителя делимое берется из регистра соответствующего разряда. Частное всегда округляется в сторону нуля (для беззнаковых и положительных - в меньшую, для отрицательных - в большую сторону). Знак остатка, вычисляемого командой `idiv`, всегда совпадает со знаком делимого, а абсолютная величина (модуль) остатка всегда строго меньше модуля делителя. Значения флагов после выполнения целочисленного деления не определены.

| разрядность (бит) | делимое | частное | остаток |
| ----------------- | ------- | ------- | ------- |
| 8                 | AX      | AL      | AH      |
| 16                | DX:AX   | AX      | DX      |
| 32                | EDX:EAX | EAX     | EDX     |

```nasm
mov ax, 7
mov bx, 3

div bx       ; теперь al хранит 2, а ah хранит 1
```
Если в делителе на момент выполнения команды `div` или `idiv` находится число ноль, то процессор инициирует *исключение*, называемое также *внутренним прерыванием*, в результате которого управление получает операционная система; в большинстве случаев она сообщает об ошибке и завершает текущую задачу как аварийную. То же самое произойдет и в случае, если результат деления не уместился в отведенные ему разряды.

#### Целочисленное расширение
При выполнении целочисленного деления чисел со знаком часто требуется выполнить расширение делимого перед началом операции.

Команды:
- `cbw` (convert byte to word) - расширяет число в регистре AL до регистра AX
- `cwd` (convert word to doubleword) - расширяет число в регистре AX до регистровой пары DX:AX
- `cwde` (convert word to dword, extended) - расширяет число в регистре AX до регистра EAX
- `cdq` (convert dword to qword) - расширяет число в регистре EAX до регистровой пары EDX:EAX

При делении беззнаковых чисел специальные команды для расширения разрядности не нужны; достаточно просто обнулить старшую часть делимого, будь то AH, DX или EDX.

### Уловные и безусловные переходы
В обычное последовательное выполнение команд можно вмешаться, выполнив **передачу управления**, называемую также **переходом**; команда передачи управления принудительно записывает новый адрес в регистр EIP, заставляя процессор продолжить выполнение программы с другого места.

Есть два типа команд перехода:
- **Безусловный переход** - выполняет передачу управления в другое место программы без всяких всяких проверок.
- **Условный переход** - в зависимости от результата проверки некоторого условия либо выполняет переход в заданную точку, либо не выполняет его, в этом случае выполнение программы, как обычно, продолжится со следующей команды.

Команды передачи управления подразделяются на три типа в зависимости от "дальности" такой передачи.
- **Дальние** (`far`) переходы подразумевают управление во фрагмент программы, расположенной в другом сегменте. Поскольку под управлением OC UNIX мы используем "плоскую" модель памяти, такие переходы нам понадобиться не могут; у нас просто нет других сегментов.
- **Близкие** (`near`) переходы передают управление в произвольное место внутри одного сегмента; фактически такие переходы представляют собой явное изменение значения EIP. В "плоской" модели памяти это именно тот вид переходов, с помощью которого мы можем "прыгнуть" в произвольное место в адресном пространстве.
- **Короткие** (`short`) переходы используются для оптимизации в случае, если точку куда надлежит "прыгнуть", отстоит от текущей команды не более чем на 127 байт вперед или 128 байт назад. В машинном коде такой команды смещение задается всего одним байтом, отсюда соответственно ограничение.

Вид перехода можно указать явно, поставив после команды слово `short` или `near` (ассмеблре понимает, разумеется, и слово `far`).

#### Безусловный переход
Команда **безусловного перехода** называется `jmp`. У команды предусмотрен один операнд, определяющий собственно адрес, куда следует передать управление. Чаще всего используется форма команды `jmp` с непосредственным операндом, то есть адресом, указанным прямо в команде; естественно, указываем мы не числовой адрес, которого обычно просто не знаем, а метку.  
Также возможно использовать регистровый операнд (в этом случае переход производится по адресу, взятому из регистра) или операнд типа "память" (адрес читается из двойного слова, расположенного в заданной позиции в памяти); такие переходы называются **косвенными**, в отличие от **прямых**, для которых адрес задается явно.
```nasm
jmp cycle    ; переход на метку cycle
jmp eax      ; переход по адресу из регистра EAX
jmp [addr]   ; переход по адресу, содержащемуся
             ; в памяти которая помечена меткой addr
jmp [eax]    ; переход по адресу, прочитанному из
             ; памяти, расположенной по адресу,
             ; взятому из регистра EAX
```
Здесь первая команда задет **прямой** переход, а остальные **косвенный**.

#### Условный переход
Команды **условных переходов** процессор поддерживает довольно много: переход может выполняться в зависимости от значения одного флага, комбинации флагов и даже в зависимости от значения регистра.

Например:
```nasm
mov eax, 9
cmp eax, 10
je exit
```
Важное замечание, в противоположность командам безусловного перехода, команды условного перехода ассемблер по умолчанию считает "короткими", если не указать тип перехода явно.
Еще один нетривиальный момент состоит в том, что *все команды условных переходов допускают только непосредственный операнд*(обычно это просто метка). Ни из регистров, ни из памяти взять адрес для такого перехода нельзя.

### Построение ветвлений и циклов
Обычный паскалевский цикл с предусловием
```pascal
while <условие> do <тело>
```
средствами машинных команд реализуется по следующей схеме:
```nasm
cycle:   <вычисление условия>
         JNx cycle_quit        ; выход
         <выполенение тела>
         JMP cycle             ; повтор
cycle_quit:
```
а ветвление в его полном варианте
```pascal
if <условие> then <ветвь1> else <ветвь2>
```
превращается в:
```nasm
         <вычисление условия>
         JNx else_branch       ; на ветку else
         <выполение ветви1>
         JMP if_quit           ; обход ветки else
else_branch:
         <выполение ветки2>
if_quit:
```

### Условные переходы и регистр ECX; циклы
В системе команд процессора имеются специальные команды для построения циклов с ECX в роли счетчика, а для других регистров таких команд нет.

#### Команда `loop`
Одна из таких команд называется `loop` и предназначена для организации циклов с заранее известным количеством итераций. В качестве счетчика цикла она использует регистр ECX, в котором перед началом цикла следует занести число нужных итераций.  
Сама команда loop выполняет два действия: уменьшает на еденицу значение в регистре ECX и, если в результате значение не стало равным нулю, производит переход на заданную метку. Команда `loop` выполняет только "короткие" переходы.

Пусть, например, есть массив из 1000 двойных слов, заданный с помощью директивы:
```nasm
array resd 1000
```
Тогда посчитать сумму его элементов можно так:
```nasm
        mov ecx, 1000   ; количество итераций
        mov esi, array  ; адрес первого элемента
        mov eax, 0      ; начальное значение сумму
lp:     add eax, [esi]  ; прибавляем число к сумму
        add esi, 4      ; адрес следующего элемента
        loop lp         ; уменьшаем счетчик
                        ; если нужно - продолжаем
```

#### Команда `jecxz`
Команда `jcxz` (jump if CX is zero) производит переход, если в регистре CX содержится ноль. Флаги при этом не учитываются. Аналогичным образом команда `jecxz` производит переход, если ноль содержится в регистре ECX. Как и для команды `loop`, этот переход короткий. Они нужны на тот случай, если в ECX уже будет содержатся ноль в первой итерации цикла.
```
        ; заполняем ecx
        jecxz lpq
lp:     ; тело цикла
		; ...
		loop lp
lpq:
```

#### Модификации команды `loop`
Модификации команды `loop`:
- `loope`(или по другому`loopz`) производит переход, если в регистре после его уменьшения на еденицу - не ноль и при этом флаг ZF установлен. 
- `loopne` (или, по другому`loopnz`) - если в регистре ECX не ноль и флаг ZF сброшен.

Уменьшение регистра ECX эти команды производят в любом случае, т.е. даже тогда, когда ZF "не в том положении".

### Побитовые операции
Информацию, записанную в регистры и память в виде байтов, слов и двойных слов можно рассматривать не только как представление целых чисел, но и как строки, состоящие из отдельных и (в общем случае) никак не связанных между собой битов.

Побитовые операции:
- `and` - логическое "И"
- `or` - логическое "ИЛИ"
- `xor` - логическое "Исключающее или"
- `not` - логическое "НЕ" / побитовое отрицание (инверсия)

Выполняют соответствующие логические операцию отдельно над первым битом обоих операндов, отдельно над вторыми битами и т.д.; результат, представляющий собой битовую строку той же длины, что и операнды заносится, как обычно для арифметических команд, в регистры или облаять памяти, определяемую первым операндом.

Ограничения на используемые операнды у этих такие же, как и у двухместных арифметических команд: первый операнд должен быть либо регистровым, либо типа "память", второй операнд может быть любого типа; нельзя использовать операнд типа "память" одновременно для первого и для второго операнда; если ни один из операндов не является не является регистровым, необходимо указать разрядность операции с поощью одного из слов (`byte`, `word`, `dword`и `qword`).

#### Команда `test`
Команда `test` работает так же, как и команда `and`, то есть выполняет побитовое "и" над своими операндами, но результат никуда не записывается, а только выставляет флаги.
```nasm
test eax, eax
jz lp
```

#### Операции побитового сдвига
Работают над всеми битами сразу, попросту сдвигая их.

Команды `shr` (shift right) и `shl` (shift left) имеют два операнда, первый из которых указывает, что сдвигать, а второй на сколько битов производить сдвиг.
- Первый операнд может быть регистровым или типа "память" (во втором случае обязательно указание разрядности).
- Второй операнд может быть либо непосредственным, то есть числом от 1 до 31 (можно указать любое число, но от него будут использоваться только младшие пять разрядов), либо регистром CL; никакие другие регистры использовать нельзя.

#### Команды арифметического побитового сдвига
Для беззнаковых чисел сдвиг на n бит влево эквивалентен умножению. на 2^n, а сдвиг вправо целочисленному делению на 2^n с отбрасыванием остатка.  
Для знаковых чисел ситуация со сдвигом влево абсолютно аналогична, а сдвиг вправо для любого отрицательного числа даст положительное.  
Поэтому введены следующие команды:
- `sal` (shift arithmetic left) делает то же самое, что и команда `shl` (на самом деле это одна и так же машинная команда).
- `sar` (shift arithmetic right) работает аналогично команде `shr`, за исключением того, что в старшем бите значение сохраняется таким же, каким оно было до операции.

![[Pasted image 20260128154908.png]]

#### Дополнительные команды побитовых операций
Процессор поддерживает также команды «сложных» побитовых сдвигов `shrd` и `shld`, работающих через два регистра; команды циклического побитового сдвига `ror` и `rol`; команды циклического сдвига через флаг CF - `rcr` u `rcl`. Могут оказаться очень полезны команды, работающие с отдельными битами своих операндов - `bt`, `bts`, `btc`, `btr`, `bsf` u `bsr`.

### Строковые операции
Для удобства работы с массивами (непрерывными областями памяти) процессор вводит несколько команд, объединяемых в категорию строковых операция. Эти команды используют регистры ESI и EDI в их особой роли.
- чтение из памяти выполняется по адресу из регистра ESI
- запись в память по адресу из регистра EDI

А затем эти регистры увеличиваются (или уменьшаются) в зависимости от команды на 1, 2 или 4. Некоторые команды производят чтение в регистр или запись в память из регистра; в этом случае используется регистр "accumulator" соответствующего размера (AL, AX или EAX). Строковые команды не имеют операндов, всегда используя одни и те же регистры.
#### Направление
Направление изменения адресов (движения вдоль строк) определяется флагом DF. Если этот флаг сброшен, адреса увеличиваются, то есть есть строковая операция выполняется слева направо; если флаг установлен - адреса уменьшаются.

Команды:
- `std` (set direction) - установить флаг
- `cld` (clear direction) - сбросить флаг

#### Строковые команды
##### Команда `stosX`
Команды `stosb`, `stosw`, `stosd` записывают в память по адресу \[edi] соответственно байт, слово или двойное слово из регистров AL, AX или EAX, после чего увеличивают или уменьшают (в зависимости от значения DF) регистр EDI на 1, 2 или 4. 

Например есть массив:
```nasm
buf resb 1024
```
и нужно заполнить его нулями, можно применить следующий код:
```nasm
		xor  al, al   ; обнуляем al
		mov edi, buf  ; адрес начала массива
		mov ecx, 1024 ; длина массива
		cld           ; работаем в прямом направлении
lp:     stosb         ; al -> [edi], увел. edi
		loop lp
```

##### Команда `lodsX`
Команды `lodsb`, `lodsw` и `lodsd`, наоборот, считывают байт, слово или двойное слово из памяти по адресу, находящемуся в регистре ESI, и помещают прочитанное в регистр AL, AX или EAX, после чего увеличивают или уменьшают значение регистра ESI на 1, 2 или 4.

Например есть массив четырехбайтных чисел:
```nasm
array resd 256
```
требуется сосчитать сумму его элементов, можно сделать так:
```nasm
		xor ebx, ebx   ; обнуляем сумму
		mov esi, array
		mov ecx, 256
		cld
lp:     lodsd
		int esx
		stsod
		loop lp
```

##### Дополнительные команды
Команды `movsb`, `movsw` и `movsd` копируют байт, слово или двойное слово из памяти по адресу \[esi] в память по удресу \[edi], после чего увеличивают (или уменьшают) сразу оба региcтра ESI и EDI соответственно на 1, 2 или 4.

##### Префикс `rep`
Команды, снабженные таким префиксом, будут выполнены столько раз, какое число было в регистре ECX.
Команда `rep` допускает и нулевое значение ECX, в этом случае строковая команда не выполняется ни одного раза.

##### Еще дополнительные команды
Кроме перечисленных, процессор реализует команды `cmpsb`, `cmpsw` и `cmpsd` (compare string - «сравнить строку»), а также `scasb`, `scasw` и `scasd` (scan string - «сканировать строку»). Команды серии `scas` сравнивают аккумулятор (соответственно AL, AX или EAX) с байтом, словом или двойным словом по адресу \[edi], устанавливая флаги подобно команде стр, и увеличивают/уменьшают EDI. Команды серии `cmps` сравнивают байты, слова или двойные слова, находящиеся в памяти по адресам \[esi] и \[edi], устанавливают флаги и увеличивают/уменьшают оба регистра.

##### Префиксы `repz` и `repnz`
Префикс `гер` для этих команд смысла не имеет, зато с командами `scasX` и `cmpsX` можно использовать префиксы `repz` и `repnz` (также называемыми `repe` и `repne`), которые, кроме уменьшения и проверки регистра ЕСХ, проверяют ещё значение флага ZF и продолжают работу, только если этот флаг установлен (`repz`/`repe`) или сброшен (`repnz`/`repne`).


### Некоторые команды
Управление флагом CF:
- Команда `stc` устанавливает
- Команда `clc` сбрасывает

Для остальных флагов такие команды не предусмотрены, только для привилегированных.

Команда `lahf` копирует содержимое регистра флагов в регистр AH:
- CF - в бит 0
- PF - в бит 2
- AF - в бит 4
- ZF - в бит 6
- SF - в бит 7

Остальные биты остаются неопределенными.

Команды `movsx` (move signed extension "перемещение со знаковым расширением") и `movzx` (move zero extension "перемещение с расширением нулями") позволяют совместить копирование с увеличением разрядности.

С помощью команды `cpuid` можно узнать на какой модели процессора выполняется наша программа и какие возможности этот процессор поддерживает.

Команды `xlat` (удобна при перекодировке текстовых данных через перекодировочную таблицу), `bswap` (позволяет переставить байты заданного 32-битного регистра в обратном порядке), `aaa`, `aad`, `aam` и `aas` (позволяют производить арифметические операции над двоично-десятичными числами, в которых каждый полубайт представляет десятичную, а не шестнадцатеричную цифру).

Команда `xchg` позволяет обменять местами значения двух своих операндов. В качестве одного из них выступает любой из регистров общего назначения, в качестве второго регистр либо операнд типа «память», имеющий тот же размер.

Неделимости действия можно добиться и от некоторых других команд - а точнее, от всех команд, которые предполагают, что из памяти будет извлечено некое значение, на его основе вычислено новое и записано в ту же память. Чтобы сделать такую команду «неделимой», её нужно снабдить префиксом `lock`.
```nasm
lock sub [m], eax
```

Команда `nop` (no operation) не делает ничего.

# Стек
Под стеком понимается непрерывная область памяти, для которой в специальном регистре хранится **адрес вершины стека**; память в рассматриваемой области выше вершины (т. е. с адресами, меньшими адреса вершины) считается свободной, а память от вершины до конца области (до старших адресов), включая и саму вершину, считается занятой; регистр, хранящий адрес вершины, называется **указателем стека**. Операция добавления в стек некоторого значения уменьшает адрес вершины, сдвигая тем самым вершину вверх (то есть в направлении меньших адресов) и в новую вершину записывает добавляемое значение; операция извлечения считывает значение с вершины стека и сдвигает вершину вниз, увеличивая её адрес.

Стек можно использовать, например, для временного хранения значений регистров.
Стек используется при вызовах подпрограмм для хранения адресов возврата, для передачи фактических параметров в подпрограммы и для хранения локальных переменных. Именно использование стека позволяет реализовать механизм рекурсии, при котором подпрограмма может прямо или косвенно вызвать сама себя.

Регистр ESP используется практически всегда в роли **указателя стека**.

Стек:  
![[Pasted image 20260128182253.png]]

### Взаимодействие со стеком
Занесение значения в стек производится командой `push`, имеющей один операнд. Этот операнд может быть непосредственным, регистровым или типа «память» и иметь размер `word` или `dword`; если операнд не регистровый, то размер нужно указать явно.

Для извлечения значения из стека используется команда `рор`, операнд которой может быть регистровым или типа «память»; естественно, операнд должен иметь размер `word` или `dword`. 

Двухбайтные операнды при работе со стеком использовать не следует(Скорее всего имеется для 32-битных процессоров); тем не менее, необходимо помнить про указание размера операнда.

Можно обратится к значению в стек без извлечения данных
```nasm
mov eax, [esp]
```

### Дополнительные команды работы со стеком
Команда `pushad` (push all doublewords) заносит в стек значения всех регистров (EAX, ECX, EDX, EBX, ESP, EBP, ESI, ESI (в указанном порядке)).
Команда `popad` (pop all doublewords) извлекает из стека восемь четырехбайтных значений и заносит эти значения в регистры в порядке обратном для `pushad`, при этом регистр ESP игнорируется (то есть из стека извлекается, но в регистр не заносится).

Регистр флагов (EFLAGS) может быть занесён в стек командой `pushfd` и извлечён командой `popfd`, однако при этом, если работаем в ограниченном режиме, только некоторые флаги (а именно - флаги, доступные к изменению в ограниченном режиме) могут быть изменены, на остальные команда `popfd` никак не повлияет.

### Вызов подпрограмм и возврат из них
Вызов подпрограммы - это передача управления по адресу начала подпрограммы с одновременным запоминанием в стеке адреса возврата. Для этого применяется команда `call`; аналогично команде `јmp`, аргумент команды `call` может быть непосредственным (адрес перехода задан прямо в команде, обычно меткой; как и для команды `јmp`, в машинном коде используется расстояние от текущей позиции, т. е. применяется относительная адресация), регистровым (адрес передачи управления находится в регистре) и типа «память» (переход нужно осуществить по адресу, прочитанному из заданного места памяти).

Возврат из подпрограммы производится командой `ret` (от слова return «возврат»). В своей простейшей форме эта команда не имеет аргументов. Выполняя эту команду, процессор извлекает четыре байта с вершины стека и записывает их в регистр ЕІР, в результате чего управление передаётся по адресу, который находился в памяти на вершине стека.

В простейшем случае параметры передаются через регистры.

Пример:
```nasm
; fill memory (edi=address, ecx=length, al=value)
fill_memory:
		jecxz fm_q
fm_lp:  mov [edi], al
		inc edi
		loop fm_lp
fm_q:   ret
```
Обратится можно так:
```nasm
mov edi, my_array
mov ecx, 256
mov al, '@'
call fill_memory
```

### Организация стековых фреймов
Параметры в стеке размещает вызывающая программа, затем при вызове подпрограммы в стек заносится адрес возврата, а затем вызванная подпрограмма резервирует место в стеке под локальные переменные. Все это вместе образует стековый фрейм.


Подпрограмма первым действие обычно сохраняет значение регистра ESP в каком-то другом регистре (чаще всего EBP)и именно его использует для доступ к параметрам и локальным переменным, а регистр ESP продолжает использоваться в качестве указателя стека. Перед возвратом из подпрограммы его обычно восстанавливают в исходном значении, попросту пересылая в него значение из EBP, чтобы он снова указывал на адрес возврата.

Каждая подпрограмма должна сама сохранить старое значение EBP и восстановить его перед возвратом управления. Поэтому \[ebp+4] содержит адрес возврата из подпрограммы.

Память под локальные переменные выделяется вычитание нужного числа из текущего значения ESP.

Структура стекового фрейма:  
![[Pasted image 20260128182212.png]]

Поэтому каждая подпрограмма должна выполнять:
```nasm
push ebp
mov ebp, esp
sub esp, 16  ; вместо 16 подствляем объем
             ; ппамяти пол локальные переменные
```

Завершение подпрограммы должно выглядеть так:
```nasm
mov esp, ebp
pop ebp
ret
```

### Основные конвенции вызовов подпрограмм

Параметры передаются через стек, но их можно передавать в разном порядке:
- слева направо (в этом случае подпрограмма должна знать сколько параметром ей передали, что обратится к первому параметру, так же очистка стека от переданных параметров возлагается на вызываемого).
- справа налево (в этом случае можно создавать так называемые вариадические функции, предполагающие переменное число аргументов).
```
push dword a3 ; заносим в стек параметры
push dword a2
push dword a1
call proc1    ; вызываем подпрограмму
add esp, 12   ; убираем параметры из стека
; в случае использования первого соглашения последняя команда не нужна,
; обо всем позаботится вызываемый
```

### Локальные метки
Суть и основное достоинство подпрограмм состоит в их обособленности.

Ассемблер NASM предусматривает **локальные метки**.  Синтаксически эти метки отличаются от обычных тем, что начинаются с точки. Ассемблер локализует такие метки во фрагменты программы, ограниченном с обех сторон обычными (нелокальными) метками. Иначе говоря, локальную метку ассемблер рассматривает не саму по себе, а как нечто подчиненное последней (ближайщей сверху) нелокальной метке.
```nasm
first_proc:
		; ... ...
.cycle:
		; ... ...
second_proc:
		; ... ...
.cycle:
		; ... ...
third_proc:
```

Ассемблер видя метку, которой начинает с точки просто добавляет к ней спереди имя последней встречавшейся ему метки без точки.

### Некоторые соглашения
Возможны различные соглашения о том, какие из регистров подпрограмма имеет право "испортить", а какие должна после себя оставить в том виде, в котором они были на момент ее вызова.
- Подпрограмме разрешается портить все регистры (вынуждает перед любым вызовом подпрограммы сохранять в стек все регистры).
- Не разрешается портить никакие регистры (тогда подпрограмма должна сама должна восстанавливать все регистры).

#### CDECL
Согласно этой конвенции подпрограмма имеет право портить EAX, EDX и ECX, а все остальные регистры общего назначения должна либо не трогать, либо сохранить и перед возвратом управления восстановить.  
Причины:
- Регистр EAX портится постоянно, поскольку многие операции можно производить только через него.
- Регистр EDX часто используется совместно с EAX.
- Регистр ECX используется в качестве счетчика во всевозможных циклах, которые встречаются очень часто.

# Основные особенности ассемблера NASM
### Ключи и опции командной строки
- **-f** - задает формат получаемого кода, в нашем случае всегда используется формат elf, если не указать этот ключ, ассемблер создаст выходной файл в "сыром" формате.
- **-o** - задет имя файла, в который следует записать результат трансляции.
- **-d** - используется для определения макросимвола.
- **-l** - генерация листинга, требуется указать имя файла (листинг - подробный отчет ассемблера о проделанной работе).
- **-g** - включает в результат трансляции отладочную информацию.
- **-e** - предписывает NASM'у прогнать наш исходный код через макропроцессор и выдать результат в поток стандартного выводы (может оказаться полезен, чтобы найти ошибку в макросе).

### Основы синтаксиса
Основной синтаксической единицей практически любого ассемблера является строка текста.

Символ "обратный слэш" ("\\") приказывает ассемблеру считать следующую строку продолжением предыдущей.

Строка текста в общем случае состоит из четырех полей: метки, имени команды, операндов и комментариев, причем метка, имя команды и комментарий являются полями необязательными. К операндам требование налагается командой.

В качестве метки можно использовать слово, состоящее из латинских букв, цифр, а также символов '\_', '$', '#', '@', '~', '.' и '?', a начинаться метка может только с буквы или символов '\_', '?' и '.'.

Метки начинающиеся с точки, считаются локальными.
В некоторых случаях имя метки можно предварить символом '$', обычно это используется, если нужно создать метку, имя которой совпадает с именем регистра, команды или директивы.

Ассемблер различает регистры букв в именах меток. После метки можно поставить символ двоеточия, но не обязательно. Обычно программисты ставят двоеточия после меток, на которые можно предавать управление, и не ставят двоеточия после меток, обозначающих области памяти.

Ассемблер NASM не различает заглавные и строчные буквы во всех словах которые он ввел сам: в именах команд, названиях регистров, директивах, псевдокомандах, обозначения длины операндов и типа переходов, но он считает заглавные и строчные различными буквами в тех именах, которые вводит пользователь(программист) - в метках и именах макросов.

В NASM операнд типа "память" всегда записывается с использованием квадратных скобок.

Комментарий обозначается символом "точка с запятой" (";").

### Псевдокоманды
Под псевдокомандами понимается ряд вводимых ассемблером NASM слов, которые могут использоваться синтаксически так же, как и мнемоники машинных команд, хотя машинными командами на самом деле не являются (например `db`, `dw`, `resb` и т.д.).

Псевдокоманда `equ` предназначена для определения констант. Эта псевдокоманда всегда применяется в сочетании с меткой. Связывает стоящую перед ней метку с явно заданным числом.
```nasm
four equ 4
```

Любая метка представляет собой не более чем число, но когда меткой снабжается строка программы, содержащая мнемонику машинной команды или директивы выделенной памяти, с такой меткой связывается соответствующий адрес в памяти (который есть тоже не что иное, как просто число), тогда как директива `equ` позволяет указать число явно.

Псевдометка `$` обозначает текущий адрес.

Часто применяют `equ` и `$` вместе, чтобы связать с некjторым именем (меткой) длину массива, только что заданного с помощью директивы.
```nasm
msg     db "Hello and welcome", 10, 0
msglen  equ $-msg
```

Директива `times` позволяет повторить какую-нибудь команду (или псевдокоманду) заданное количество раз.
```nasm
stars times 4096 db '*'
```
 В данном случае задет область памяти размером в 4096 байт, заполненную кодом символа '\*'.

Псевдокоманда `incbin` позволяющая создать область память, заполненную данными из некоторого внешнего файла.

### Константы
 Делятся на 4 вида:
 - целые числа
 - символьные константы
 - строковые константы
 - числа с плавающей точкой

Целочисленные константы можно задать в:
- двоичной
- восьмеричной
- десятичной
- шестнадцатеричной

Символьные константы и строковые константы очень похожи друг на друга, более того в любом месте, где  по смыслу должна быть строковая константа, можно употребить и символьную.
Разница между ними только в их длине: под символьной константой подразумевается такая константа, которая укладывается в длину "двойного слова". И символьные и строковые константы могут записываться как с помощью двойных кавычек, так и с помощью апострофов.

Константы с плавающей точкой, задающие дробные числа синтаксически отличатся от целочисленных констант наличием десятичной точки. Целочисленная константа 1 и константа 1.0 не имеют между собой ничего общего.
Константу с плавающей точкой можно задать и в экспоненциальном виде, используя букву 'e' как 'E'. Например, 1.0e-5 есть то же самое, что и 0.00001 (десятичная точка по-прежнему обязательна).

### Вычисление выражений во время ассемблирования

Ассемблер NASM в некоторых случаях вычисляет встретившиеся ему арифметические выражения непосредственно во время ассемблирования. В итоговый машинный код попадают только вычисленные результаты, а не сами действия по их вычислению. Все, что нужно для вычисления, должно быть известно ассемблеру во время его работы.

Выражение должно быть целочисленным и использовать операции из следующего списка:
- `+` и `-` - сложение и вычитание
- `*` - умножение
- `/` и `%` - целочисленное деление и остаток от деления (для беззнаковых целых чисел)
- `//` и `%%` - целочисленное деление и остаток от деления (для знаковых целых чисел)
- `&`, `|`, `^` - операции побитового "И", "ИЛИ", "Исключающего или"
- `<<` и `>>` - операции побитового сдвига влево и вправо
- унарные операции `-` и `+` используются в их обычной роли: `-` меняет знак числа на противоположное, `+` не делает ничего
- унарная операция `~` обозначает побитовое отрицание

При применении операций `%` и `%%` нужно обязательно оставлять пробельный символ после знака операции, чтобы ассемблер не перепутал их с макродирективами.

### Критические выражения
Ассемблер анализирует исходный текст в два прохода:
- Первый проход:
	- Вычисляется размер всех команд и данных.
        - Каждой метке присваивается конкретный числовой адрес.
- Второй проход:
	- Генерируется машинный код.
	- Подставляются адреса меток, вычисленные на первом этапе.

**Критическое выражение** - это выражение, значение которого ассемблер обязан вычислить уже на первом проходе.
Выражение считается критическим, если от него зависит размер занимаемой памяти (длина команды или резервируемой области).

# Макросредства и макропроцессор

Под **макропроцессором** понимают программное средство, которое получает на вход некоторый текст и, пользуясь указаниями, данными в самом тексте, частично преобразует его, давая на выходе, в свою очередь, текст, но уже не имеющий указаний к преобразованию.

В применении к языкам программирования **макропроцессор** это преобразователь исходного текста программы, обычно совмещённый с компилятором; результатом работы макропроцессора является текст на языке программирования, который потом уже обрабатывается компилятором в соответствии с правилами языка.

Схема работы макропроцессора:  
![[Pasted image 20260129134152.png]]

**Макросом** называют некоторое правило, в соответствии с которым фрагмент программы, содержащий определённое слово, должен быть преобразован. Само это слово называют **именем макроса**.

Фрагмент программы, определяющий макрос, называют **макроопределением**. Когда макропроцессор встречает в тексте программы имя макроса и параметры (так называемый **вызов макроса**, или **макровызов**), он заменяет имя макроса (и, возможно, параметры, относящиеся к нему) фрагментом текста, полученным в соответствии с определением макроса. Такая замена называется **макроподстановкой**, а текст, полученный в результате - **макрорасширением**.

### Макродирективы
**Макродирективы** - более прямые указания.

`%include` - макродиректива, которая приказывает макропроцессору заменить ее саму на содержимое файла, указанного параметром директивы.
```nasm
%include "stud_io.inc"
```

### Многострочный макрос
Макрос может иметь несколько входных параметров.

**Тело макроса** - шаблон текста, который должен получится в результате макроподстановки. В теле макроса можно использовать параметры, указанные при его вызове - они обозначаются `%1`, `%2`, `%3`, `%4` ... `%9`, а `%0` обозначает их общее количество, параметров может быть и больше девяти.
```
%macro <имя макроса> <кол-во параметров макроса>
		<тело макроса>
%endmacro
```

### Однострочные макросы
**Однострочный макрос** - это такой макрос, определение которого состоит из одной строки, а его вызов разворачивается во фрагмент строки текста(то есть может использоваться для генерации части строки).

```nasm
%define <название макроса>
```
Ассемблер NASM поддерживает соглашение о том, что любое обращение у памяти оформляется с помощью квадратных скобок, если же их нет, то мы имеем дело с непосредственным или регистровым операндом.  
Поэтому так писать не стоит:
```nasm
%define arg1 [ebp+8]

mov eax, arg1
```
Нужно писать так:
```nasm
%define arg(n) ebp+(4*n)+4
$define local(n) ebp-(4*n)

mov [arg(7)], edx
```

Единожды определенный макрос можно при необходимости переопределить, просто вставив в текст программы еще одно определение того же макроса. 

Макрос также можно убрать воспользовавшись директивой `%undef`.

### Стратегия макроподставновок
**Ленивая** стратегия макроподставновок - макропроцессор как бы "ленится" выполнит макроподстановку, пока его не вынудят.

Пример:
```nasm
%define thenumber 25
%define mkver dd thenumber
```
Если теперь написать в программе строчку:
```nasm
var1 mkvar
```
то макропроцессор сначала выполнить макроподстановку для "mkvar"
```nasm
var1 dd thenumber
```
а из нее, в свою очередь, макроподстановкой "thenumber" получит строку
```nasm
var1 dd 25
```
Если теперь переопределить "thenumber" и снова вызвать mkvar:
```nasm
%define thenumber 36
var2 mkvar
```
то результатом работы макропроцессор будет строка:
```nasm
var2 dd 36
```

**Энергичная** стратегия макроподстановок - если в теле описания макроса встречаются макровызовы, макропроцессор производит их макроподстановки незамедлительно, то есть прямо в момент обработки макроопределения. Задается с помощью директивы `%xdefine`.

Например:
```nasm
%define thenumber 25
%xdefine mkvar dd thenumber
var1 mkvar
%define thenumber 36
var2 mkvar
```
то обе получившиеся строки будут содержать число 25:
```nasm
var1 dd 25
var2 dd 25
```

### Макропеременные
Макроимена, вводимые директивой `%assign`, обычно называются **макропеременными**.  В отличие от `%define` и `%xdefine` эта директива не только выполняет все подстановки в теле макроопределения, но и пытается вычислить тело как обыкновенное целочисленное арифметическое выражение.

Если написать:
```nasm
%assign var 25
```
а потом:
```nasm
%assign var var+1
```
то в результате с макроименем "var" будет связано значение 26.

### Условная компиляция
Условная компиляция, зависящая от определения однострочного макроса:
1) `%ifdef` - это одна из директив условной компиляции, означающая "компилировать только в случае, если определен указанный однострочный макрос".
2) `%elifdef` - следующая проверяемая ветвь условий.
3) `%else` - если ни одно условие не выполнено.
4) `%endif` - завершение условия условной компиляции
```nasm
%ifdef F_FIRST
;
;    code for first
;
%elifdef F_SECOND
;
;    code fir second
;
%else
%error Some error message
%endif
```
Так же ключ/флаг можно указать при компиляции
```
-dF_FIRST
```

Кроме проверки наличия макросимвола, можно проверять также и факт отсутствия макросимвола:
`ifndef`, `elifndef`.

Общая директива `%if`, в которой условие задается арифметико-логическим выражением, вычисляемым во время компиляции. Для нее есть `%elif`.

Набор допустимых операций расширяется операциями `=`, `<`, `>`, `>=`, `<=`, в их обычно смысле, операцию "не равно" можно задать символом `<>` или символом `!=`, так же есть такая запись `==`. Также доступны логические связки `&&`("И"), `||`("ИЛИ"), `^^`("Исключающее или").

Все выражения, используемые в директиве `%if`, рассматриваются как критические.

Имеется достаточно много других разных директивной условной компиляции, но тут только обращаться к официальной документации.

### Макроповторения


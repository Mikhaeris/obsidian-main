Введение
		C - язык программирвания общего назначения(язык системного програмиирования).
	Тесная связь с Unix, в которой и для которой он разрабатывался.
	Указатели, поеддерживается механизм системно-независимой адресной арифметики.
	На этепе препроцессорной обработки выполняются макроподставновки, включение дополнительнх файлов  и условная компиляция.
# **Глава 1** Вводный урок  
### 1.1 Первые шаги
```c
#include <stdio.h>

int main()
{  
	printf("Hello, world!");  
	return 0;
}
```
### 1.2 Переменные и арифметические выражения
Элементарные типы данных:
- char - символ (один байт)
- short - корокое целое число
- int - целочисленное типо
- long - длинное целое число
- float - число с плавающей точкой
- double - число с плавающей точкой двойной точности

Неявное преобразование типов пристутсвует - меньшее преобразовывается в большее (по байтам).
Остальные базовые вещи, по типу сложения, вычитания, умножения, деления, деление с остатком.
### 1.3 Оператор for
```c
#include <stdio.h>

int main()
{
	int i;
	
	for (i = 0; i < 10; ++i)
	{
		printf("%i\n", i);
	}
	
	return 0;
}
```
Оператор for - это оператор цикла, обобщение оператора while(Или по другому while - частный случай оператора for).
		for (инициалиция; условие; модификация или приращение управляющих циклом переменных).
### 1.4 Символические константы
```c
#define LOWER 0
```
.
		Значение подставляется в программу
	1.5 Символный ввод-вывод
```c
getchar() /* Взять символ из потока */
putchar() /* Засунуть символ в поток */
```
.
	1.6 Массивы
```c
int array[10]; /* Создается миссив на стеке из 10 элементов, индексирование начинается с нулю 
переменная указывает на начало массива. т.е. можно напистаь *array - и выведется первый элемент(так как array - это указатель, который указывает на первый элемент массива -> разыменовав его получаем значение нулевого элемента).
*/
```
.
	1.7 Функции
```c
int power(int m, int n); /* Прототип функции */

int main()
{
	...
}

int power(int base, int n) /* Определение функции */
{
	int i, p;

	p = 1;
	for (i = 1; i <= n; ++i)
	{
		p = p * base; /* p *= base; */
	}
	return p;
}
/*
типо-возвращяемого-значения имя-функции(объявления параметров)
{
	объявления
	операторы
}
*/
```
.
			Функция - это удобный способ свести в одном место (инкапсулировать)
		некоторые вычислительные операции, а затем обращаться к ним много разЮ не беспокоясь об особенностях реализации.
	1.8 Аргументы: передача по значению
			В C вызываемая функция не может модифицировать переменные в
		вызывающей функции, она вправе изменять только свои локальные, временные копии жтих переменных.
			По необходимости вызывающая функция может передавать адрес
		переменной (указатель на переменную), а вызываемая - люъявитьпараметр указателем и обращаться к переменной косвенно, по ссылке через указатель.
	1.9 Массивы символов
```c
char s[10]; /* Массив символов */
```
.
			Массив чаров, где каждый элемент это символ. В конце стоит специальный знак окончания строки '\0'.
	1.10 Внешние переменные
			Те же самые переменные, но доступные в каждом месте программы.
		Использовать не рекомендуется, так как при частом использование поведение может быть запутанным и неожиданным.
		Хранятся в специальном месте в памяти для глобальных переменных.
		
**Глава 2** Типы данных, операции и выражения
	2.1 Имена переменных
			Имя переменной может состоять из букв и цифр, но начинаться всегда
		должно с буквы. Первым символом переменной не стоит использовать \(\_\), так как библиотеки используют это. Регистр влияет. 31 символ считается значащим, для имен функций и внешних переменных это количество может быть меньше 31, потмоу что они внешние имена могут использоваться ассемблерами и загрузчиками, над которыми у языка нет никакого контроля.
	2.2 Типы данных и их размеры
		Базовые типы данных:
			char - один байт, содержащий символ из локального символьного набора.
			int - целое число, типовой размер для целых чисел в данной системе.
			float - число одинарной точности с палвающей точкой.
			double - число двойной точности с плавающей точкой.
		Модификаторы:
			Для целых чисел: short, long
			Знаковые: signed, unsigned (могут применять к char или целочисленному)
			long double
	2.3 Константы
			В конце литерала можно записать его тип (например L и т.д. со всеми
		типами). Если начинается с 0 - значит записано в восьмиричной системе, елси с 0x - значит в шестнадцатеричной.
			Символьная константа записывается в 'x'(число), а строковая(литерал) в
		"x"(массив символов и в конце заверщающий нуль).
			Константное выражение - это выражение, содержащее только константы.
		Такие выражения могут вычилсять в ходе компиляции, а не выполнения программы.
				Констанеты перечислимого типа - определяется списком
			целочисленных констант, первая константа в списке получает - 0, вторая - 1, если не указаны явные значения.
```c
enum boolean { NO, YES }; /* NO - 0, YES - 1 */

enum months { JAN = 1, FEB, MAR ...} /* FEB = 2, MAR = 3 ...*/
```
.
		Имена в различных перечислениях должны быть различными. Значения констант в одном перечислении не обязаны быть различными. Иногда перечисления могут быть удобнее  define.
	2.4 Объявления
		Все переменные необходимо объявить до их использования. В объявлении указывается тип и список из одной или нескольких переменных этого типа.
```c
int lower, upper, step;
char c, line[1000];

/* или */

int lower;
int upper;
int step;
char c;
char line[1000];

/* так же переменные можно инициализировать прямо в обяъвлениях */
char esc = '\\';
int  i = 0;
int  limit = MAXLINE + 1;

/* константные переменные - значение после инициализации больше не меняется*/
const double e = 2.71828182845905;
/* может применятся аргументами функции и массивами*/

```
.
	2.5 Арифметические операции
		Двуместные арифметические операции: +, -, \*\, /, %.
		Операция % не примени к типам с плавающей точкой. Приоритет похож на математический.
	2.6 Операции отношения и логические операции
			К операциям отношения принадлежат следующие: >, >=, <, <=.
		Имеют одинаковый приоритет.
			Следом за ними идут \==, !=.
		Операции отношения и сравнения имеют более низкий приоритет, чем арифметические операции.
			Логические операции: &&(и) и ||(или). Приоритет && выше, чем у ||,  но у обое имеют приоритет ниже, чем сравнения и отношения.
		Одноместная операция отрицания (!) превращает ненулевой операнд в 0, а нулевой в 1.
	2.7 Преобразование типов
		Корректные автоматические преобразования, когда более "узкий" тип преобразуется в более "широкий" тип. В остальном все преобразования очень логичны.
		Принудительное преобразование (имя-типа) выражение. Преобразуется по правилам выше.
```c
sqrt((double)n);
```
.
		Приведение типка пораждает новое значение нужного типа, никак не изменяя исходную переменную. Имеет такой же высокий приоритет, как и другие однометстные операции.
	2.8 Операции инкрементирования и декрементирования
		Операция инкрементировния ++ добавляет к своему операнду еденицу, а операция декрементирования -- отнимает.
		Могут быть префиксными и постфиксными.
			Префиксная сначала прибавляет, а затем возвращает,
			Постфиксная сначала возвращает, а потом прибавляет.
	2.9 Поразрядные операции
		Имеется шесть битовых(поразрядных) операций:
			&   - поразрядное И.
			|    - поразрядное включающее ИЛИ.
			^    - поразрядное исключающее ИЛИ.
			<< - сдвиг влево.
			>> - сдвиг вправо.
			~   - одноместное поразрядное дополнение до еденицы
		Эти операции применимы только к целочисленным аргументам:
			char, short, int, long.
	2.10 Операции с присваиванием и выражения с ними
		Укороченные версии операторов присваивания
```c
i = i + 2;
i += 2;
```
.
	2.11 Условные выражения
		Тернарный оператор:
```c
if (a > b)
{
	z = a;
}
else
{
	z = b;
}

z = (a > b) ? a : b;
```
.
	2.12 Приоритет и порядок вычисления
		Таблиаца приоритета и ассоциирования операция.
**Глава 3** Управляющие конструкции
	3.1. Операторы и блоки
		В языке С точка с запятой является элементов оператора и его завершающейся частью, а не разделительным опреаторм, как в языке Pascal.Фигурные скобки служат для группировки объявлений и операторов в составные операторы, или блоки, синтаксически эквиваленты одному оператору.
	3.2. Оператор if-else
		Нужно следить за неоднозначностю опреаторов и желательно всегда ставить скобки, чтобы не вызыватьдвухсмысленность.
```c
if (n > 2)
{
	a = n;
}
else {
	a = 0;
}
```
.
	3.3. Конструкция else-if
		Проверка условий идет сверху вниз, как только одно условие выполнилось, цепочка прирывается.
```c
int binsearch(int x, int v[], int n)
{
	int low, high, mid;
	
	low = 0;
	high = n -1;
	while (low <= high)
	{
		mid = (low+high) / 2;
		if (x < v[mid])
		{
			high = mid - 1;
		}
		else if (x > v[mid])
		{
			low = mid + 1;
		}
		else
		{
			return mid;
		}
	}

	return -1;
}
```
.
	3.4. Оператор switch
		Стоит избегать сквозного выполения switch case.
```c
switch (c)
{
	case: '0': case '1':
		puts("number);
		break;
	case ' ':
		puts("space");
		break;
	default:
		break;
}
```
.
	3.5. Циклы - while и for
```c
while (/* выражение */)
{
	/* оператор */
}

for (/* выражение1 */; /* выражени2 */; /* выражение3*/)
{
	/* оператор */
}
```
.
		В выражениях в цикле for следет избегать других операций, кроме управления самим циклом for.
			Операцию "запятая" следует использовать как можно реже и с
		осторожностью. Наиболее уместно ее применение в конструкциях, где объединяются в единое целое связанные друг с другом операции, как, например, в теле цикла for в функции reverse, или в макросах, где многошаговые вычисления объединяются в одну операцию. Запятую вполне можно применить при обмене местами элементов в функции reverse, поскольку этот обмен можно представить себе единой операцией.
	3.6. Циклы - do-while
		Проверка условия в конце - значит тело цикла точно выполнится один раз.
```c
do
{
	/* оператор */
}
while (/*выражение*/)
```
.
	3.7. Операторы break и continue
		break - завершает работу цикла и switch.
		continue - переходит к следующей итерации.
	3.8. Оператор goto и метки
```c
for (i = 0; i < n; ++n)
{
	for (j = 0; j < m; ++j)
	{
		if (a[i] == b[j])
		{
			goto found;
		}
	}
}

found:
	/* какие-то действия */
```

**Глава 4** Функции и структура программы
	4.1. Основы создания функций
		Функции могут принимать любое количество аргументов, но возвращать только одно значние или не возврашать ничего.
	4.2. Функции, возвращающие нецелые значения
		Нужно в коде явно показать, что функция возвращает другое знчение, иначе компилятор увидит эту функцию первый раз и сделает ее объвление без аргументов с возвращаемым значением int(по дефолту).
```c
int main()
{
	char line[MAX_LINE] = "123.654";
	double sum, atof(char []);

	sum += atof(line);
}
```
.
	4.3. Внешние переменные
		Внешние переменные имеют глобальную область видимости, они предоставляют собой способ обмена данными между функциями.
	4.4. Область действия
		Локальные переменные виды только внутри функций.
		Внешние переменные видны везде, но стоит учитвать, что переменные видны тфункциям, которые находятся ниже них. Чтобы дать доступ и верхним функциям нужно добавить слово extern(только объявляет переменную, то не определяет.) Чтобы получить доступ к переменной из другого файла нужно в начале этого файла объявить эту переменную.
	4.5. Заголовочные файлы
		![[Pasted image 20250803030121.png]]
	4.6. Статические переменные
			Ключевое слово static ограничивает область видимости этой внешней
		переменной/функции от точки объявления до конца этого файла.
			Ключвое слово static для локальной переменной работает по
		другому: статические внутренние переменные продолжают существовать непрерывно, а не создаются и уничтожаются при вызове и завершении функции.
	4.7. Регистровые переменные
			Объявление переменной с ключевым слово register сообщает
		компилятору, что соотвутсвующая переменная будет интенсивно использоваться программой. Как бы говорим, что эту переменную можно поместить в регистр процессора для быстрой работой с ней, но компилятор имеет право игнорировать эту информацию. От лишних объявлений переменной с ключевым слово register не бывает никакого вреда, посколько избыточные или неразрешенные обхвляения просто игнорируются компилятором.
			НО не разрешается вычислять адрес регистровой переменной,
		независимо от того, помещена ли она на самом деле в регистр процессора.
		Конкретные ограничения на количество и три регистровых переменных зависят от системы и аппаратного обеспечения.
	4.8. Блочная структура
		Язык С не является полноценнм блочно-структурным.
		Но в нем есть объявление и использование локальных переменных в жтом блоке кода, например объявленная переменная в if будет действовать только в этом блоке до закрытия фигруной скобки и так со всеми операторами.
	4.9 Инициализация
			При отсутствие явной инициализации внешние и стаические переменные
		гарантированно инициализируются нулями, а автоматические и регистровые получают неопредленные начальные значения(мусор).
			Скалярные переменные можно инициализировать прямо при
		объявлении, поставив после имени знак равенства и выражение.
			Инициалиазирующие выражения для внещних и статических
		переменных должны быть константными(инициализация выполняется один раз, фактически до начала выполнения программы). А для автоматических и регистровых переменных инициализация выполняется каждый раз при входе в соответствующий блок.
	4.10 Рекурсия
		Рекурсия - функция вызывает сама себя.
	4.11 Препроцессор С
				Первый этап компиляции - препроцессоринг.
			Два наиболее часто используемых - это директива \#include, включающая все содержимое заданнго файла в компилируемый код, и директива \#define, заменяющая некий индетификатор заданной последовательностью символов.
		4.11.1 Включение файлов
			С помощью включения файлов можно легко распоряжаться набором директив \#define и объявлений(среди прочего).
```c
#include "file_name"
#include <file_name>
```
.
			При обработке текста строка заменяется содержимым файла имя_файла. Если указано в кавычках, то поиск начинается с того места, где находится исходный текст программы. Если его там нет или имя файла заключено в угловые скобки, то поиск файла продлжается по праивлам зависящим от реализации языка.
		4.11.2. Макроподстановки
			Эта конструкция задает макроопределение или макрос:
```c
#define имя текст-для-замены
#define max(A, B)  ((A) > (B) ? (A) : (B))

#ubdef max /* отменяет определение имени */

#define dprint(expr) printf(#expr " = %g\n", expr)
/* dprint(x/y)
   printf("x/y" " = %g/n", x/y);*/

#define paste (front, back) front ## back
/* Выражение рaste (name, 1) порождает идентификатор пате 1. */
```
.
			Можно так же определить макрос с аргументами.
				Макросы очень опасны, есть много ловушек, но все же они
			бывают очень полезными.
				Если в текте водстновки перед именем формального параметра
			стоит значок #, то эта комбинация заменяется строкой в кавычках, в которые вместо формального параметра подставляется аргумент.
				Операция препроцессора ## предоставляет возможность сцепить
			фактические аргу-менты в одну строку в процессе раскрытия макроса. Если параметр в подставляемом тексте находится рядом со знаком ##, этот параметр заменяется фактическим аргумен-том, сам знак ## и окружающие его пробелы удаляются, а результат снова анализируется препроцессором.
				Правила использования вложенных знаков ## загадочны и
			малопонятны.	
		4.11.3 Условное включение
				Дают возможность управлять самой препроцесорной обработкой. Это делет возможным условное включение фрагментов кода в
					программу в зависимости от условий, выполняющихся в омент компиляции.
			Директивы \#if, \#elif, \#else - работают как обычные операторы.
			В следующем фрагменте кода анализируется имя SYSTEМ и принимается решение, какую версию заголовочного файла включать в программу:
```c
#if SYSTEM == SYSV
	#define HDR "sysv.h"
#elif SYSTEM == BSD
	#define HDR "bsd.h"
#elif SYSTEM MSDOS ==
	#define HDR "msdos.h"
#else
	#define HDR "default.h"
#endif
#include HDR
```
.
			Директивы \#ifdef u \#ifndef — это специальные формы условной директивы для проверки того, определено то или иное имя или нет. Первый пример директивы \#if, приведенный в начале раздела, можно было бы записать так:
```c
#ifndef HDR
#define HDR
/* здесь находится содержимое файла hdr.h */
#endif
```
.
**Глава 5** Указатели и массивы
	Указатель - это переменная, содержащая адрес другой переменной.
	5.1. Указатели и адреса
		Одноместная (унарная) операция & дает адрес объекта.
```c
p = &c; /* в p хранится адрес переменной c*/
```
.
		Или p укзывает на c.
			Операция & применима только к объектам, хранящимся в оперативной
		памяти: переменным и элементам массивов. Ее нельзя применить к выражениям, константным и регистровым переменным.
		Одноместная операция * называется операцией ссылки по указателю(indirection) или разыменованием (dereferencing). Применяя ее к указателю, получаем объект, на который он указывает.
```c
int x = 1, y = 2, z [10];
int *ip;        /* ip указатель на int */

ip = &x;        /* ір теперь указывает на х */
y = *ip;        /* у теперь равно 1 */
*ip = 0;        /* х теперь равно 0 */
ip = &z [0];    /* ір теперь указывает на z [0] */

double *dp, atof (char *);

iq = ip;
```
.
			Исключение является указатель на void, в котором может содержаться
		произвольный адрес без указания на тип данных, однако по указателю этого типа нельзя ссылаться и получать значения.
			Однометные операции * и &  имеют более высокий приоритет для своих
		операндов, чем арифметические операции.
		Указатели можно употреблять сами по себе, без разыменования.
	5.2. Указатели и аргументы функций
		Аргументы в функции передаются по значению, поэтому изменяются их копии. Чтобы это функция могла изменять сами объекты, нужно передать адрес, а функция принимает указатель.
```c
void swap (int *px, int *py) /* обмен местами *рх и *ру */
{
	int temp;
	
	temp = *px;
	*px = *py;
	*py = temp;
}
```
.
		![[Pasted image 20250803062106.png]]
	5.3. Указатели и массивы
		Любую операцию, выплняемую с помощью индексации массива, можно проделать с применением указателей, причем код с применением указателей обычно работает быстрее, но для непосвященных выглядит более запутанно.
```c
int a[10];
/*переменная 'a' всего лишь хранит адрес на нулевой элемент массива, а не на весь массив*/
*a /* поэтому такая операция выведет нулевой элемент массива*/
a[i] == *(a+i) /* или тоже тождественны */ &a[i] == a+i 
```
.
			Отсюда можно сказать, что выражение в виде обращения к массиву по
		индексу эквивалентно ссылке по указателю со смещением.
			Однако есть и одно различие между именем массива и указателем.
		Указатель является переенной, так что выражение pa=a и pa++ допустимы. А вот конструкции наподобие a=pa и a++ не разрешены. (где pa = &a)
		Если в функцию передать имя массива, по сути туда поступает адрес первого элемента. В вызванной функции этот аргумент является локальной переменной, так что имя массива в виде параметра функции - это указатель, т.е. переменная, содержащая адрес.
```c
/* например */
int strlen(char *s)
{
	int n;
	
	for (n = 0; *s != '\0'; s++) {
		n++;
	}

	return n;
}

/* вызов */
strlen("hello, world");
strlen(array);
strlen(ptr);

/* Следующие две форму эквиваленты, если употреблять в виде формальных параметров функции: */
char s[];
char *s;

/* Вторая форма предпочтительнее, потому что онаболее явно выражает тот факт, что параметр является укзателем. Когда в функцию передается имя массива, функция имеет право сама решать, обходиться с ним как с массивом или как с указатлем. Если это удобно и не портит удобочитаемость, можно даже комбинировать оба способа */
/* так же можно передать только часть массива */
f(&a[2])
f(a+2)
/* так же можно индексировать массив в противоположном направлении, если есть уверенность, что там есть массив */
```
.
	5.4. Адресная арифметика
		К числу разрешенных операций с указателями относятся:
			1) Присваивание указатлей одного типа
			2) Сложение или вычитание укзателя и целого числа
			3) Вычитание или сравнение указатлей, указывающих на один и тот же массив данных
			4) Присваивание нуля или сравнение с ним
			Любые другие операции с адресами являются ошибками и неразрешены.
			Нельяза складывать два указателя, умножать, делить, сдвигать или прменять маски к указателям, прибавлять к ним числа типа float или  double. За исключением указатлей тива void * нельзя даже присвоить указатель одного типа указателю другого без явного приведения типов.
	5.5. Символьные указатели и функции
		Во внутреннем представлении строки она заканчивается нулевым символом '\0', чтобы программа могла найти ее конец(значит длина строки на один символ больше).
		Обращение к строковой константе выполняется по указателю на ее первый элемент.
```c
char *pmessage;
/* Тогда следующий оператор присваивает ей указатель на массив символов */
pmessage = "now is the time";
/* При этом не выполняется копирование строки */
```
.
		В языке С нет операций для манипулирования именно строкой символов как единым целым, вместо этого применяются операции с указателями.
```c
char amessage[] = "now is the time";  /* массив */
char *pmessage = "now is the time"    /* указатель */
```
.
		В первом из них amessage - это массив, ровно такой длины, чтобы в него поместилась инициализирующая строка символов и завершающий '\0'. Отдельные символы в строке можно изменить, но переменная amessage всегда будет указывать на один и тот же участок памяти.
		А вот pmessage -  это указатель, который после инициализации указывает на строковую константу, впоследвствии этот указатель можно изменить так, чтобы он указывал в другое место, но попытка изменить содержимое строки после этого даст неопредленный результат.
	5.6. Массивы указателей и указатели на указатели
		Поскольку указатели сами по себе являются переменныыми, их можно хранить в массивах, как и переменные других типов.
```c
char *lineptr[MAXLINES]; /* Статический массив указателей на строки(выделяется на стеке или глобально) */
```
.
	5.7. Многомерные массивы
```c
char daytab[i][j]; /* [строка][столбец] */

/* Передача в функцию двумерного массива */
f(char daytab[2][13]) { }
f(char daytab[][13]) { }
f(char (*daytab)[13]) { } /* Без скобок это было бы оъявление массива из 13 указателей на данные типа char */
/* При передачи двумерного массива в функцию количество строк не имеет значения */
```
.
	5.8. Инициализация массивов указателей
```c
static char *name[] = {
	"Illegal month",
	"January", "February", "March",
	"April", "May", "June",
	"July", "August", "September",
	"October", "November", "December"
};
```
.
	5.9. Указатели и многомерные массивы
		Не стоит путать двмерные массивы и массивы указателей.
```c
int a[10][20];
int *b[10];

/* a[3][4] и b[3][4] - законное обрещение к одному элементу данных типа int */
```
.
			При этом a - полноправный двумерный массив, для него выделено 200
		ячеек памяти размера int, и для поиска элемента a\[строка]\[столбец] используется перевод координат прямоугольного массива в линейный адрес по формуле 20 x строка + столбец.
			А вот для переменной b - ее определение всего лишь выделяет память
		для 10 указателей без их инициализации, инициализация должна пвыполняться явным образом - статически или программно. Предполагая, что каждый элемент b действительно указывает на массив из дадцати элементов, получаем те же 200 ячеек типа int плюс десять ячеек для указатлей. Важно преимущество массива указателей состоит в том, что строки массива могут иметь различную длину, т.е. каждый элемент b не обязан указывать на вектор из 20 элементов. Одни указатели могут указывать на два элемнта, жругие - на пятьдесят, а третье - вообще ни на что.
	Наглядный пример:
		Массив указателей на строки:
			![[Pasted image 20250823222048.png]]
		Двумерный массив строк:
			![[Pasted image 20250823222104.png]]
	5.10. Аргументы командной строки
			В системных средах, поддерживающих язык C, существует способ
		передавать в программу аргументы или параметры командной стоки при запуске программы на выполение. При вызове функции main она получает два аргументы. Первый, который обычно назвают argc (от argument count - счетчик аргументов), содержит количетсво аргументов командной строки, с которыми была запущено программа. Второй, обычно под именем argv (от argument vector - вектор аргументов), указывает на массив символьных строк, содержищих сами аргуенты, - по одному в строке. Для манипулирования этими символьными строками, естественно, используется многоуровневая система указателей.
```c
int main(int argc, char *argv[]) {
	...
}
```
.
			По определению argv\[0] содержит имя, под которым запускается
		программа, поэтому argc всегда не меньше 1. Если счетчик argc равен 1, то после имени программы нет никаких аргументов командной строки. Первый необязательный аргумент хранится в argv\[1], а последний - в argv\[argc-1]. Кроме того, стандарт требует, чтобы элемент argv\[argc] был нулевым указателем.
		-
			В программанх на C в системе Unix принято, чтобы необязательные
		аргументы или ключи начинались со знака "минус". Кроме того, они могут стоять в любом порядке. Для большего удобства пользователей желетельно также, чтобы аргументы-ключи можно было комбинировать.
	5.11. Указетели на функции
		В языке C функция сама по себе не является переменной, но зато можно определить укзатели на функции, которые разрешено присваивать, хранит в массивах, передавать в функции, возвращать из функции и т.п.
```c
/* Объясвление функции, которая принимает четвернтым аргументом указатель на функцию */
void qsort(void *lineptr[], int left, int right,
		   int (*comp)(void *, void *));
/* Здесь сообщается, что comp - это укащзатель на функцию, принимабщую два аргумента типа void * и возвращающую числа типа int */
/* Испольщваоние comp в функции согласовано с объявлением */
if ((*comp)(v[i], v[left]) < 0)
/* Поскольку comp - указатель на функцию, то *comp - это сама функция, а вызов ее выполняется соответсвенное таким образом */
(*comp)(v[i], v[left])
/* Кргулые скобки нужны для установления правильных связей между компонентами выржения, без них получилось бы объявление функции, возвращающей указатель на int, т.е. нечто совершенно другое */
int *comp(void *, void *) /* В данном случае это непраивльно */

/* Передача в функцию указатель на функцию (вызов верхней функции)*/
qsort((void **) lineptr, 0, nlines-1,
	(int (*)(void*, void*))(numeric ? numcmp : strcmp));
/* При вызове функции qsort имена strcmp и numcmp являются указателями */

/* Тут происходит приведение указателя функции к другому типу, напмриер */
int my_func(char *, char *);
int (*p)(char*, char*) = my_func;
int (*pv)(void*, void*) = (int (*)(void*, void*)) my_func;
```
.
		Поскольку это функции, знак & перед ними не нужен, точно так де , как он не был нужен перед именами массивов.\
		Любой указатель можно привести к типу void * и обратно без  потери информации. Фактически внутренее представление данных редко зависит от наличия такого приведения, но все же лучше убдеить компилятор, что в вызове все правильно.
	5.12. Сложные объвления
			Язык C иногда обвиняют в чрезмерно сложном синтексесе объявлений - в
		частности, тех, в которых участвуют указатели на функции. Синтаксис языка построен так, чтобы объявление и использование переенных были максимально согласованы. Для простых случаев это получается вполне удачно, а вот длясложных может возникнуть путаница, поскольку объявления не всегда читаются слева направо, да еще и бывают перегружены скобками.
		![[Pasted image 20250827173034.png]]
		
**Глава 6** Структуры
		Структура - это совокупность нескольних переменных, часто различных типов,
	сгруппированных под единым именем для удобства обращения. Например список работников какго-нибудь предприятия: в нем каждый сотрудник описывается набором таких атрибутов, как имя, адрес, номер полиса социального страхования, размер зарплаты и т.д. Некоторые из этих атрибутов сами могут быть структурами: напрмиер, имя состоит из нескольких компонентов, как адрес, и даже зарплата. Еще один приер, более типичный для C, взят из компьютерной графики: точка описывается парой координат, прямоугольник - парой точек и т.д.
	.
	6.1. Основы работы со структурами
```c
struct point {
	int x;
	int y;
};
```
.
			Ключевым словом struct начинается объявление структуры, состоящей из
		списка объявлений элементов в фигурных скобках. 
			После слова struct может стоять необязательный индентификатор,
		именуемый меткой структуры. Метка обозначает конкретный структурный тип; впоследствии ее можно использовать для краткости, опуская все, что находится в скобках при объявлении структур того же вида.
			Переменные, перчисленные в объявлении структуры, называются ее
		членами, элементами или полями. Элемент структуры или ее метка может иметь то же имя, что и обыкновенная переменная (не поле структуры) безо всякого конфликта, поскольку они всегда отличаются по контексту. Более того, в разных структурах можно использовать одни и то же имена элементов, хотя с точик зрения хорошего стиля так можно делать того тогда, когда речь идет о близкородственных объектах.
			Объявление со словом struct фактически вводит новый тип данных. После
		правой скобки, завершающей список жлементов, может стоять список переменных, как и после имени любого элементарного типа.
```c
struct { ... } x, y, z;
/* идентично по синтаксису что и */
int x, y, z;
/* Каждый из этих двух операторов объявляет переменные x, y, z определенного именованного типа и выделяет для них место в памяти*/
```
.
			Объявление структуры, после которого нет списка переменных, не
		выделяет ниаккой памяти для объектов, а просто описывает форму или "шаблон" структуры. Если в объвлении присутсвует метка, ее можно использовать позже при опредении экземпляров структуры.
```c
/* Объявление переменной pt, имеющей тип  struct point */
struct point pt;

/* Структуру можно инициализировать, поставив после ее определения список значений-констант */
struct point maxpt = { 320, 200 };
```
.
			Обращение к элементам структуры (при включении их в выражение и т.п.) выполняется с помощью следующей конструкции:
				имя-структуры.элемент
			Структуры можно вкладывать друг в друга.
```c
/* Структура rect содержит две структуры point */
struct rect {
	struct point pt1;
	struct point pt2;
};
```
.
	6.2. Структуры и функции
			Разрешенными операциями над структурами являются копирование или
		присваивание структуры как целого, взятие ее адреса операцией &, а также обращение к ее элементам. Копирование и присваивание включают в себя также передачу аргументов в функции и возвращение значений из функций.
			Структуры нельзя сравнивать между собой. Структуру можно
		инициализировать списком констант-инициализаторов для всех ее полей; автоматическую структуру также можно инициализировать присваиванием.
			Структуры можно передавать в функции напрямую или по указателю на них.
```c
/* Указатель на структуру */
struct point *pp;

*pp /* сама структура */
(*pp).x, (*pp).y /* поля этой структуры (сначала разымыминовываем указатель и потом обращаемся к полю структуры) */
p->x, p->y /* Дополнительное удобное обозначение. При компиляции анализируется слева направо */

/* Напрмирер */
struct rect, *rp = &r;
/* Следующие четыре выражения эквивалентны */
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
```
.
			Операции обращения к структурам (точки и ->) наряду с круглыми
		скобками для вызовов функций и квадратными для индексов массивов находятся на самой вершине иерархии приориетов.
```c
++p->len /* инкрементирует len, а не p */
++(p->len) /* аналогично предыдущей записи */

/* С помощью скобок можно изменить порядок применения операций*/
(++p)->len /* инкрементирует p до объявления к len */
(p++)->len /* инкрементирует p после обращения (тут можно опустить скобки */

*p->str /* возвращает значение, на которое указывает str */
*p->str++ /* инкрементирует str после обращения к тому, на что указывает это поле (как и *s++) */
(*p->str)++ /* инкрементирует то, на что указывает str */
*p++->str /* инкрементирует p после обращения к данным, на которые указывает str */
```
.
	6.3. Массивы структур
```c
/* Объявление и определение массива структур */
struct key {
	char *word;
	int coint;
} keytab[NKEYS];
/* или */
struct key {
	char *word;
	int count;
};

struct key keytab[NKEYS];

/* */
```
.
			Размер всего массива структур равен длине одного элемента,
		умноженной на количество элементов, поэтому количетство элементов соответсвенно составляет: 
			размер keytab / размер struct key 
			В языке C есть одноместная операция sizeof, выполняемая при
		компиляции с помощью которой вычислется размер любого объекта. Следующие два выражения дают в результате целое число, равное размеру заданного объекта или типа в байтах:
			sizeof объект
			sizeof(имя типа)
		Строго говоря, операция sizeof дает целое значение без знака, тип которого называется size_t и определен в загаловочном файле <stddef.h>. Объектом операции может быть переменная, массив или структура. Имя типа может бать оменем базового типа, намремер структуры или указателя.
```c
sizeof keytab;
sizeof(struct key);
sizeof keytab[0];
```
.
	6.4. Указатели на структуры
		С указателями на структуры можно делать много всего интересного.
		Так же не следует полагать, что длина структры равна сумме длин ее элеентов. Различные объекты по-разному выравниваются по машинным словам, поэтому внутри структуры могут быть наименовынные "дыры". Например, если тип char имеет длину 1 байт, а тип int 4 байта, то следующая структура может фактически занимать в памяти восемь байт, а не пять:
```c
struct {
	char c;
	int i;
};
```
.
		Операция sizeof всегда дает правильное значение размера объекта.
		Если функция возвращает сложный тип данных наподобие указателей на структры, ее имя часто бывает трудно различить в тексте или найти в текстовом редакторе:
```c
struct key *binsearch(char *word, struct key*tab, int n)
```
.
		Поэтому иногда используют другую форму записи:
```c
struct key *
binsearch(char *word, struct key *tab, int n)
```
.
	6.5. Структуры со ссылками на себя
			Хорошим примером может позлужить двоичное дерево.
			Дерево содержит один узел для каждой информации, отличающейся от
		всех других; каждый такой узел содердит информацию:
			- информация
			- указатель на левый дочерний узел
			- указатель на правый дочерний узел
		Узел не может иметь больше двух дочерних узлов, но может иметь один или не иметь ни одного.
```c
/* Пример ноды двоичного дерева */
struct tnode {
	char *word;
	int count;
	struct tnode *left;
	struct tnode *right;
};
```
.
		Структуре не разрешается иметь в качестве компонента экземпляр самой себя, но здесь объявляется указатель на tnode, а не сама структра.
```c
struct tnode *left;
```
.
		Иногда встречается и такая разновидность структур, ссылающихся на себя, как струтры, ссылающиеся друг на друга.
```c
struct t {
	...
	struct s *p;
}
struct s {
	...
	struct t *q;*
}
```
.
		Функция malloc и ее аналоги из стандартой библиотеки(конкретно из <stdlib.h>) выделяют память в куче(учитывая выравнивание) и возвращают указатель на тип void(этот указатель можно легко привести к любому другому).
		Функция malloc возвращает NULL, если она не может выделить участок памяти.
		Память, выделенную вызовом malloc, можно(скорее нужно, даже обязательно) освободить вызовом функции free.
	6.6. Поиск по таблице
		Подглава уделена небольшой реализации хэш-таблицы.
	6.7. Определение новых типов
		В языке C есть такое специальное средство для определения имен новых типов данных, как оператор typedef.
```c
/* Синоним типа int под названием Length */
typedef int Length;
/* Теперь имя Length можно использовать в объявлениях, приведениях типов и т.п. точно так же, как имя самого типа int */
Length len, maxlen;
Length *lengths[];

/* Аналогично, следующее объявление делает имя String синониом указателя на символьные данные(char *)*/
typedef char *String;
/*  Объявление и приведение типов перменных с его использованием */
String p, lineptr[MAX_LINES], alloc(int);
int strcmp(String, String);
p = (String) malloc(100);
```
.
			Стоит обратить внимание, что имя нового типа, объявляемое в typedef,
		стоит не сразу после ключевого слова, а на месте имени переменной. Синтаксически ключевое слово typedef можно считать аналогом идентификатра класса памяти - например, extern, static и т.п.
			Новые типы, определеяемые с помощью typedef, начинаются с прописной
		буквы, чтобы можно было их легко различить.
```c
/* Содаются два новых ключевых слова для типов. Один тип называется Treenode (это структура), а второй - Treeptr (указатиель на стрктуру)*/
typedef struct tnode *Treeptr;

typedef struct tnode {
	char *word;
	int count;
	struct tnode *left;
	struct tnode *right;
} Treenode;
```
.
			Объявление typedef не создает совершенного нового типа, с его помощью
		определяется новое имя для некоторого уже существующего типа данных.
			Нет в нем и никаких смысловых тонкостей: переменные, объявленные
		таким образом, имеют точно такие жу свойства, как и переменные, тип которых выписан явно, без "псевдонима".
			Фактически оператор typedef очень напоминает директиву \#define с тем
		исключением, что, поскольку он анадизируется компилятором, он может допускать такие текстовые подстановки, которые препроцессору не по силам.
```c
/* определяется тип PFI - "указатель на функцию от двух аргументов типа char *, возвращающую int */
typedef int (*PFI)(char *, char *);
/* использование */
PFI strcmp, numcmp;
```
.
			Для применения оператора typedef есть две основные побудительные
		причины, помимо стилевых и вкусовых предпочтений.
			Первая - это возможность параметризовать программу с целью
		улучшения переносимости. Если используемые в программе типы данных могут зависеть от системы и аппаратной конфигурации компьютера, их можно определить через typedef, а затем при переносе заменять только эти определения.
			Вторая причина - это возможность улучшить удобочитаемость, сделать
		программу самодокументированной. Название типа может оказаться более информативным, чем просто указатель на какую-то сложную структуру(или функция возвращающую массив указателей на функции, которые возвращают указатели на чары).
	6.8. Объеденения
			Объединение - это переменная, которая может содержать объекты
		различных типов и размеров (но не одновременно), при этом удовлетворение требований к размеру и выравниванию возлагается на компилятор. С помощью объединений можно работать с данными различных типов в пределах одного участка памяти, не привнося в программу элементы низкоуровневого, машинно-зависимого программирования. 
```c
union u_tag {
	int ival;
	float fval;
	char *sval;
} u;
```
.
			Обращение к элементам объединения выполняется так же, как к
		элементам структур.
			Объединения могут употребляться в структурах и массивах, и наоброт.
		Способ обращения к члену объединения в структуре (или к члену структуры в объединении) полностью идентичек обращению к элементам вложенной структры.
```c
struct {
	char *name;
	int flags;
	int utype;
	union {
		int ival;
		float fval;
		char *sval;
	} u;
} symtab[NSYM];
/* Обращение к элементу ival */
symtab[i].u.ival;
/* Обращение к первому символу строки sval */
*symtab[i].u.sval;
symtab[i].u.sval[0];
```
.
			Фактически объединение является структурой, в которой все элементы
		имеют нулевое смещение от ее начала, сама она имеет достаточную длину, чтобы в нее поместился самый длинный элемент, и при этом выравнивание выполняется правильно для всех типов данных в объединении. Над объединениями разрешено выполнять те же операции, что и над структурами: присваивать или копировать как единое целое, брать адрес и обращаться к отдельным элементам.
			Объединение можно инициализировать только данными того типа,
		который имеет его первый элемент.
	6.9. Битовые поля
		Когда требуется экономить память некоторые переменные удобно хранить как несколько битов. Например для флажко. Самый компактный способ закодировать такую информацию - это поместить ее в виде однобитовых переключателей в одну переменную типа char или int.
		Обычный способ сделать это - определить набор "масок", соответсвующих битовым позициям в переменной.
```c
#define KEYWORD  01
#define EXTERNAL 02
#define STATIC   04
/* или */
enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };

/* Здесь числовыве константы должны быть степенями двойки. После этого обращения к отдельным битов сводится к сдвигу, применению маски и взятию дополнения. Некоторые операции встречаются так часто, что превратились в устойчивые конструкции(идиомы)*/

/* Вот так включаются (устанавливаются равными единице) биты признаков EXTERNAL и статик в переменнйо flsgs */
falgs |= EXTERNAL | STATIC;
/* А отключаются они(устанавливаются равными нулю) */
flags &= ~(EXTERNAL | STATIC);
/* Следующее вырадение истинно, если оба бита отключены */
if ((flags & (EXTERNAL | STATIC)) == 0)
```
.
		В языке C имеется возможность определения полей внутри машинного слова непосредственно, а не с помощью поразрядных операций. Внутри системно-зависимой еденицы памяти, которая называется "словом" можно задать битовое поле(bit-field) - совокупность идущих подряд битов. Синтаксиси определеия и использования полей основан на структурах.
```c
/* Определяется переменная flags, содержащая три однобитовых поля. Число после двоеточия задает ширину поля в битах. Поля объявлены как unsigned int, чтобы гарантированно быть величинами без знака */
struct {
	unsigned int is_keyword : 1;
	unsigned int is_extern  : 1;
	unsigned int is_static  : 1;
} flags;
/* Обращение к полям */
flags.is_keyword, flags.is_extern;
/* по своим свойствам поля являются небольшими целыми числами и могут употребляться в выражениях в этом качестве. */
/* Включение битов(установки их в еденицу */
flags.is_extern = flags.is_static = 1;
/* Отключение битов(установка в нуль) */
flags.is_extern = flags.is_static = 0;
/* Анализ значекний */
if (flags.is_extern == 0 && flags.is_static == 0)
```
.
		Практически все, что связано с битовыми полями, является системно-зависимым. На-пример, только в конкретной реализации определяется, могут ли поля перекрывать гра-ницы слов. Поля не обязаны иметь имена; безымянные поля (двоеточия с размером после них) часто используются для пропуска и резервирования отдельных битов. Для при-нудительного выравнивания по границе следующего слова можно использовать специ-альное значение длины поля, равное 0.
		В некоторых системах поля выстраиваются слева направо, а в других - справа налево. Это означает, что хотя с помощью полей удобно работать с внутренними структурами данных, в случае обработки внешних структур следует тщательно подходить к вопросу о том, с какого конца начинать. Программы, зависимые от такого порядка, не переносимы между системами. Поля можно объявлять только с типом int; с целью переносимости лучше явно указывать модификатор signed или unsigned. Совокуп-ность полей не массив, и у них нет адресов, поэтому операция & к ним неприменима.
**Глава 7** Ввод-вывод
	7.1. Стандартные средства ввода-вывода
		Есть два основных потока(отсюда и происходит название io, I/O):
			1) Стандартный поток ввода(standard input)
				С помощью '<' можно перенапрвлять поток ввода в программу из файла, при этом программа ничего не заметит.
				Так же с помощью символа '|' можно перенапрять ввод из другой программы.
			2) Стнадартный поток выводы(standard output)
				С помощью '>' можно перенапрвлять поток вывода в программу из файла, при этом программа ничего не заметит.
				Так же с помощью символа '|' можно перенапрять вывод из программы в другую программу.
		Стандартная библиотека реализует эти удобные функции в <stdio.h>
	7.2. Форматированный вывод и функция printf
		Функция printf преобразует данные из внутренних форматов в выводимое символы.
```c
int printf(char *format, arg1, arg2, ...)
```
.
			Функция printf преобразует, форматирует и выводит свои аргументы в
		стандартный поток выводы согласно строке формата - format. Она возвращает количество выведенных символов.
			Строка формата содержит два типа объектов: обычные символы, которые
		копируют-ся в поток вывода, и спецификации формата, каждая из которых вызывает преобразова-ние и вывод очередного аргумента функции printf. Каждая спецификация формата на-чинается с символа % и заканчивается символом типа преобразования. Между % и симво-лом типа могут стоять по порядку следующие элементы.
		- Знак "минус", задающий выравнивание выводимого аргумента по левому краю отведенного поля вывода.
		- Число, задающее минимальную ширину поля. Преобразованный аргумент выво-дится в поле, ширина которого не меньше, чем заданная. Если необходимо, поле дополняется пробелами слева (или справа, если это задано) до указанной длины.
		- Точка, отделяющая ширину поля от точности представления.
		- Число (точность представления), задающее максимальное количество символов при выводе строки, или количество цифр в вещественном числе после десятичной точки, или минимальное количество цифр для целого числа.
		- Буква һ, если целое число следует вывести как короткое (short), или буква 1, ес-ли как длинное (long).
		Символы преобразования находятся в документации. Если после занака % стоит не спецификация формата, а что-то друго, результат будет непредсказуемым.
			Ширину или точность можно указать в виде символа \*. В этом случае
		нужное значе-ние будет вычисляться по следующему аргументу (который должен иметь тип int). На-пример, вывод не более тах символов из строки в выполняется так:
```c
printf("%.*s", max, s);
```
.
			Почти все спецификации формата уже иллюстрировались примерами в
		предыдущих главах. Одно из исключений состоит в применении параметра точности к строкам. Сле-дующая таблица показывает, как работают разные спецификации при выводе строки "hello, world" (12 символов). Каждое поле вывода окружено двоеточиями, чтобы было видно его длину:
```
:%s:          :hello, world:
:%10s:        :hello, world:
:%.10s:       :hello, wor:
:%-10s:       :hello, world:
:%.15s:       :hello, world:
:%-15s:       :hello, world   :
:%15.10s:     :     hello, wor:
:%-15.10s:    :hello, wor     :
```
.
		Функция sprintf выполняет те же преобразования, что и printf, но помещает результат вывода в символьнудю строку.
```c
int sprintf(char *string, char *format, arg1, arg2, ...)
```
.
	7.3. Списки аргументов переменной длины
```c
int printf(char *format, ...)
```
.
		Конструкция ... означает, что количество и типы аргументов могут меняться. Такая конструкция может стоять только в конце списка аргуентов.
		В <stdarg.h> имеется набор макроопределений, дающих способ перебора списка безымянных аргументов.
		Для объявления переменной, ссылающейся по очереди на каждый аргумент, имеется тип va_list. Макрос va_start инициализирует переменную типа va_list чтобы переменная указывала на первый бузыменный аргумент. Этот макрос нужно вызвать только один раз.
		Функция должна иметь как минимум один аргумент с именем; последний именнованный аргумент используется макросом vs_start для инициализации своей работы.
		Каждый вызов va_arg возвращает один аргумент и передвигает указатель типа va_list на слудеющий. Чтобы определитьЮ какого типа аргумент нужно возвращать ит на сколько передвигать указатель, va_arg использует заданное ему имя типа.
		Макрос va_end выполняет необходимые завершающие операции. Его необходимо вызвать до возвращения из функции.
	7.4. Форматированный ввод и функция scanf
		Функция scanf очень сильно похожа на printf, но она не выводит данные, а считывает их и изписывает в переменные. Важное правило - аргументы данной функции должны быть указатели.
		Строка формата обычно содержит спецификации формата, используемые для управ-ления преобразованием входных данных. В строке формата могут содержаться следую-щие элементы:
		- пробелы или табуляции, которые игнорируются при вводе;
		- обыкновенные символы (не %), которые должны соответствовать ожидаемым оче-редным непустым символам в потоке ввода;
		- спецификации формата, состоящие из символа %; необязательного символа запре-та присваивания ; необязательного числа максимальной ширины поля; необя-зательного символа һ, 1 или 1, обозначающего длину представления числа, и соб-ственно символа типа/формата.
		Спецификация формата регулирует преобразование очередного элемента данных (поля ввода) в потоке к заданному типу и форме. Как правило, результат помещается в переменную, на которую указывает соответствующий аргумент. Если присваивание за-прещено символом \*, то элемент данных пропускается, и никакого присваивания не происходит
	7.5. Доступ к файлам
		Когда программа на C запускается на выполнение, операционная система автоматически открывает три файла и создает файловые указатели на них. Это стандартный поток ввода, стандартный поток вывода и стандартный поток ошибок. Соответсвубющие указатели называются stdin, stdout и stderr; они объявлены в файле <stdio.h>. Обычно stdin ассоциирован с клавиатурой, а stdout и stderr - с экраном монитора, но stdin и stdout можно ассоциировать с файлами или конвейерами(перенаправить). Файловые указатели stdin и stdout являются объектами типа FILE \*. Это константы, а не переменные, поэтому им нельзя присваивать какие-либо значения.
			Чтобы читать из файла нужно открыть файл.
```c
FILE *fp = fopen(name, mode);
```
.
		Здесь fp указывает на структуру FILE(это структура, сожержащая информацию о файле: местонахождение буфера, текущую символьную позицию в буфере, характер операций (чтение или запись), наличие ошибок и состояние конца файла. Так же эта структура объявлена в файле <stdio.h>).
		Первый аргумент fopen - это символьная строка, содержащая имя файла. Второй аргумент - режим открытия; это также символьная строка, указывающая способ использования файла. Допускаются режимы чтения "r" (от "read"), записи "w" ("write") и добавления данных в конце файла "a" ("append"). В некоторых системах делается различие между текстовыми и двоичными файлами; для работы с двоичными файлми следует добавить в троку режима буку "b" (от "binary"). Если файл, открываемый для записи или добваления в конец, не существует, предпринимается попытка его создания. Открытие существующего файла для записи стирает все его содержимое, а открытие для добавления - сохраняет. Попытка читать из несуществующего файла является ошибкой. Если произошла ошибка функция fopen возвращает NULL.
```c
/* получения символа из потока(файла) */
int getc(FILE *fp); /* возвращает символ из потока, при ошибке или в случае конца файла возвращает EOF */

/* запись символа в поток(файл) */
int putc(int c, FILE *fp); /* возвращает записанный символ, при ошибки фозвращает EOF */
/* Обе эти функции могут быть макросами */

/* Функции getchar и putchar можно определить через getc, putc и stdin, stdout */
#define getchar()   getc(stdin)
#define putchar(c)  putc((c), stdout)
```
.
		Для форматированного файлового ввода-вывода можно ползоваться функциями fscanf и fprintf. Они аналогичны scanf и printf, только их первым аргументом служит файловый указатель, а стрка форматат стоит на втором месте.
```c
int fscanf(FILE *fp, char *format, ...);
int fprintf(FILE *fp, char *format, ...);
```
.
		Обратную к fopen роль играет функция fclose. Она разрывает связь между внешним именем и файловым указателем, установленную функцией foреп, тем самым освобождая указатель для другого файла. Поскольку в большинстве операционных систем имеется ограничение на количество одновременно открытых программой файлов, полезно закрывать файлы и освобождать их указатели, как только файлы становятся ненужными. Есть и еще одна причина применить fclose к открытому файлу в результате очищается и сбрасывается в файл буфер, в котором функция putc накапливает выходные данные. Функция fclose вызывается автоматически для каждого открытого файла во время нормального завершения программы. (Можно даже закрыть stdin и stdout, если они не нужны. Их можно затем переназначить библиотечной функцией freopen.)
```c
int fclose(FILE *fp);
```
.
	7.6. Обработка ошибок. Поток stderr и функция exit
		Для вывода ошибок существует терйти поток - stderr(стандратный поток ошибок), данные выведенные с помощь. него обычно появляются на экране.
```c
/* Пример работы с stderr */
fprintf(stderr, "%s: error writing stdout\n", prog);
```
.
		Так же есть станадартная библиотечная функция exit, которая прекращает работу программы. Аргумент exit становится доступным тому процессу, которыйзапустил программу на выполение(принято, что возвращаемое значение 0 сигнализирует о номрмальном заверщении).  Функция exit вызывает fclose, для закрытия каждого открытого файла, очищая тем самым буфер вывода. В программе main  конструкция return *выражение* эквивалентно выражению exit(*выражение*). Функция exit имеет то преимущество, что ее можно вызвать из других функций.
	7.7. Ввод-вывод строк
			Функция fgets считывает очередную строку(вместе с символом ее конца) из файла fp в массив символов line, получившаяся строка завершается нулевым символом '\0'. Обычно fgets возвращает line, в конце файла или в случе ошибки она возвращает NULL.
			С помощью функции fputs производится запись строки в файл. Функкция возвращает EOF в случае ошибки и 0 в противном случае.
			Библиотечные функции gets и puts аналогичны fgets и fputs но работают с потока stdin и stdout. Функция gets удаляет завершающий символ '\n', а puts добавляет его, что частно вызывает путаницу.
	7.8. Различные функции
		7.8.1. Операции со строками
			Эти функции опредлены в <string.h>
			Далее в списке s и t имеют тим char \*, а c и n - тип int.
```c
strcat(s, t)      /* присоединяет t в хвост к s */

strncat(s, t, n)  /* присоединяет n символов из t в хвост к s */

strcmp(s, t)      /* дает отрицательно, нуль или поожительное число пи s < t, s == t, s > t соответственно */

strncmp(s, t, n)  /* то же, что и strcmp, но выполняется над первыми n символами */

strcpy(s, t)      /* колпирует t в s */

strncpy(s, t, n)  /* копирует не более n символов t в s */

strlen(s)         /* вычисляет длину s */

 strchr(s, c)      /* возвращает указатель на первый символ c в s или NULL, если символ не найден */
 
strrchr(s, c)     /* возвращает указатель на послений символ c в s или NULL, если символ не найден */
```
.
		7.8.2. Анализ, классификация и преобразование символов
			Несколько функций из файла <ctype.h>  выполяют анализ и преобразование символов. Далее считается, что c - число типа int, которое можно интерпретировать как unsigned char, либо EOF. Все функции возвращают int.
```c
isalpa(c)   /* не нуль, если c - алфавитный символ; 0, если нет */
isupper(c)  /* не нуль, если c - буква в верхнем регистре; 0, если нет */
islower(c)  /* не нуль, если c - буква в нижнем регистре; 0, если нет */
isdigit(c)  /* не нуль, если c - цифра; 0, если нет */
isalnum(c)  /* не нуль, если c выполняется isflpha(c) или isdegit(c); 0, если нет */
isspace(c)  /* не нуль, если c - пробел, табуляция, конце строки, возврат каретки, перевод страницы, вертикальная табуляция */
toupper(c)  /* возвращает символ c, приведенный к верхнему регистру */
tolower(c)  /* возвращает символ c, приведенный к нижнему регистру */
```
.
		7.8.3. Функции ungetc
			Функция int ungetc(int c, FILE \*fp) - помещает символ c назад в файл fp и возвращает либо c, либо EOF в случае ошибки. Для каждого файла гарантрирован возврат только одного символа. Функцию ungetc можно использовать совместно с любой из функций ввода scanf, getc или getchar.
		7.8.4. Выполнение команд
			Функция system(char \*) выполняет команду, содержащуюся в символьной строке s, а затем возобновляет выполнение текущей программы. Допустимое содержимое строки s сильно зависит от конкретной операционной среды. Функция system возвращает целочисленный код завершения выполнения команды, который зависит от характеристик системы. В системе Unix код завершения представляет собой значение, передаваемое с помощью функции exit.
		7.8.5. Управление памятью
			С помощью функций malloc и calloc выполняется динамическое распределение блоков памяти. Функция malloc возвращает указатель на n байт неинициализированной памяти или NULL, если запрос на память нельзя выполнить:
```c
void *malloc(size_t n)
```
.
		Функция calloc возвращает указатель на участок памяти, достаточный для размещения n объектов заданного размера size или NULL, если запрос на память невыполним. Память инициализируется нулями.
```c
void *calloc(size_t n, size_t size)
```
.
		Указатель, возвращаемый функциями malloc и calloc, выровнен в памяти надлежащим образом, но его еще нужно привести к нужному типу:
```c
int *ip;

ip = (int *) calloc(n, sizeof(int));
```
.
		Функция free(p) освобождает участок памяти, на который указывает указатель p, первоначально полученный вызовом функции malloc или calloc. Порядок освобожения выделенных участков памяти не регламентируется. Однако если указатель не был получен с помощью malloc или calloc, то его освобождение является грубой ошибкой.
```c
/* Обращение по указателю после его освобождения — также ошибка. Часто встречает-
ся неправильный фрагмент кода, в котором элементы списка освобождаются в цикле: */
for (p = head; p != NULL; p = p->next) /*НЕПРАВИЛЬНО*/
    free(p);

/* Правильным было бы записать все, что нужно перед освобождением: */
for (p = head; p != NULL; p = q) {
    q = p->next;
    free(p);
}
```
.
		7.8.6. Математические функции
			В заголовочном файле <math.h> объвляено больше двадцати математических функций. Каждая принимает один ии два аргуента типа double и возвращает результат типа double.
```c
sin(x) /* синус x, x в радианах */
cos(x) /* косинус x, x в радианах */
atan2(y, x) /* арктангенс отношения y/x в радианах */
exp(x) /* экспоненциальная функция (e в степени x) */
log(x) /* натуральный логарифм x (x > 0) */
log10(x) /* десятичный логарифм x (x > 0) */
pow(x, y) /* x в степени y */
sqrt(x) /* квадратный корень из x (при условии x >= 0) */
fabs(x) /* абсолютное значение x */
```
.
		7.8.7. Генерирование случаный чисел
			Функция rand() вычисляет последовательность псевдослучайных целых чисел в диапазоне от 0 до RAND MAX величины, определенной в файле <stdlib.h>. Вот один из способов генерировать случайные вещественные числа, большие или равные ну-лю, но меньшие единицы:
```c
#define frand() ((double) rand() / (RAND_MAX+1.0))
```
.
			Учтите, что если в библиотеке вашего компилятора уже есть функция для вычисления случайных вещественных чисел, то она, скорее всего, имеет лучшие статистические свойства, чем приведенная.
			Функция srand(unsigned) устанавливает для rand инициализирующее значение.

Продолжение - 8
cтраница 182

Введение
		C - язык программирвания общего назначения(язык системного програмиирования).
	Тесная связь с Unix, в которой и для которой он разрабатывался.
	Указатели, поеддерживается механизм системно-независимой адресной арифметики.
	На этепе препроцессорной обработки выполняются макроподставновки, включение дополнительнх файлов  и условная компиляция.
**Глава 1** Вводный урок
	**1.1 Первые шаги**
```c
#include <stdio.h>

int main()
{  
	printf("Hello, world!");  
	return 0;
}
```
-
	1.2 Переменные и арифметические выражения
		Элементарные типы данных:
			char - символ (один байт)
			short - корокое целое число
			int - целочисленное типо
			long - длинное целое число
			float - число с плавающей точкой
			double - число с плавающей точкой двойной точности
			-
		Неявное преобразование типов пристутсвует - меньшее преобразовывается в большее (по байтам).
		Остальные базовые вещи, по типу сложения, вычитания, умножения, деления, деление с остатком.
	1.3 Оператор for
```c
#include <stdio.h>

int main()
{
	int i;
	
	for (i = 0; i < 10; ++i)
	{
		printf("%i\n", i);
	}
	
	return 0;
}
```
-
		Оператор for - это оператор цикла, обобщение оператора while(Или по другому while - частный случай оператора for).
		for (инициалиция; условие; модификация или приращение управляющих циклом переменных).
	1.4 Символические константы
```c
#define LOWER 0
```
-
		Значение подставляется в программу
	1.5 Символный ввод-вывод
```c
getchar() /* Взять символ из потока */
putchar() /* Засунуть символ в поток */
```
-
	1.6 Массивы
```c
int array[10]; /* Создается миссив на стеке из 10 элементов, индексирование начинается с нулю 
переменная указывает на начало массива. т.е. можно напистаь *array - и выведется первый элемент(так как array - это указатель, который указывает на первый элемент массива -> разыменовав его получаем значение нулевого элемента).
*/
```
-
	1.7 Функции
```c
int power(int m, int n); /* Прототип функции */

int main()
{
	...
}

int power(int base, int n) /* Определение функции */
{
	int i, p;

	p = 1;
	for (i = 1; i <= n; ++i)
	{
		p = p * base; /* p *= base; */
	}
	return p;
}
/*
типо-возвращяемого-значения имя-функции(объявления параметров)
{
	объявления
	операторы
}
*/
```
-
			Функция - это удобный способ свести в одном место (инкапсулировать)
		некоторые вычислительные операции, а затем обращаться к ним много разЮ не беспокоясь об особенностях реализации.
	1.8 Аргументы: передача по значению
			В C вызываемая функция не может модифицировать переменные в
		вызывающей функции, она вправе изменять только свои локальные, временные копии жтих переменных.
			По необходимости вызывающая функция может передавать адрес
		переменной (указатель на переменную), а вызываемая - люъявитьпараметр указателем и обращаться к переменной косвенно, по ссылке через указатель.
	1.9 Массивы символов
```c
char s[10]; /* Массив символов */
```
-
			Массив чаров, где каждый элемент это символ. В конце стоит специальный знак окончания строки '\0'.
	1.10 Внешние переменные
			Те же самые переменные, но доступные в каждом месте программы.
		Использовать не рекомендуется, так как при частом использование поведение может быть запутанным и неожиданным.
		Хранятся в специальном месте в памяти для глобальных переменных.
		
**Глава 2** Типы данных, операции и выражения
	2.1 Имена переменных
			Имя переменной может состоять из букв и цифр, но начинаться всегда
		должно с буквы. Первым символом переменной не стоит использовать \(\_\), так как библиотеки используют это. Регистр влияет. 31 символ считается значащим, для имен функций и внешних переменных это количество может быть меньше 31, потмоу что они внешние имена могут использоваться ассемблерами и загрузчиками, над которыми у языка нет никакого контроля.
	2.2 Типы данных и их размеры
		Базовые типы данных:
			char - один байт, содержащий символ из локального символьного набора.
			int - целое число, типовой размер для целых чисел в данной системе.
			float - число одинарной точности с палвающей точкой.
			double - число двойной точности с плавающей точкой.
		Модификаторы:
			Для целых чисел: short, long
			Знаковые: signed, unsigned (могут применять к char или целочисленному)
			long double
	2.3 Константы
			В конце литерала можно записать его тип (например L и т.д. со всеми
		типами). Если начинается с 0 - значит записано в восьмиричной системе, елси с 0x - значит в шестнадцатеричной.
			Символьная константа записывается в 'x'(число), а строковая(литерал) в
		"x"(массив символов и в конце заверщающий нуль).
			Константное выражение - это выражение, содержащее только константы.
		Такие выражения могут вычилсять в ходе компиляции, а не выполнения программы.
				Констанеты перечислимого типа - определяется списком
			целочисленных констант, первая константа в списке получает - 0, вторая - 1, если не указаны явные значения.
```c
enum boolean { NO, YES }; /* NO - 0, YES - 1 */

enum months { JAN = 1, FEB, MAR ...} /* FEB = 2, MAR = 3 ...*/
```
-
		Имена в различных перечислениях должны быть различными. Значения констант в одном перечислении не обязаны быть различными. Иногда перечисления могут быть удобнее  define.
	2.4 Объявления
		Все переменные необходимо объявить до их использования. В объявлении указывается тип и список из одной или нескольких переменных этого типа.
```c
int lower, upper, step;
char c, line[1000];

/* или */

int lower;
int upper;
int step;
char c;
char line[1000];

/* так же переменные можно инициализировать прямо в обяъвлениях */
char esc = '\\';
int  i = 0;
int  limit = MAXLINE + 1;

/* константные переменные - значение после инициализации больше не меняется*/
const double e = 2.71828182845905;
/* может применятся аргументами функции и массивами*/

```
-
	2.5 Арифметические операции
		Двуместные арифметические операции: +, -, \*\, /, %.
		Операция % не примени к типам с плавающей точкой. Приоритет похож на математический.
	2.6 Операции отношения и логические операции
			К операциям отношения принадлежат следующие: >, >=, <, <=.
		Имеют одинаковый приоритет.
			Следом за ними идут \==, !=.
		Операции отношения и сравнения имеют более низкий приоритет, чем арифметические операции.
			Логические операции: &&(и) и ||(или). Приоритет && выше, чем у ||,  но у обое имеют приоритет ниже, чем сравнения и отношения.
		Одноместная операция отрицания (!) превращает ненулевой операнд в 0, а нулевой в 1.
	2.7 Преобразование типов
		Корректные автоматические преобразования, когда более "узкий" тип преобразуется в более "широкий" тип. В остальном все преобразования очень логичны.
		Принудительное преобразование (имя-типа) выражение. Преобразуется по правилам выше.
```c
sqrt((double)n);
```
-
		Приведение типка пораждает новое значение нужного типа, никак не изменяя исходную переменную. Имеет такой же высокий приоритет, как и другие однометстные операции.
	2.8 Операции инкрементирования и декрементирования
		Операция инкрементировния ++ добавляет к своему операнду еденицу, а операция декрементирования -- отнимает.
		Могут быть префиксными и постфиксными.
			Префиксная сначала прибавляет, а затем возвращает,
			Постфиксная сначала возвращает, а потом прибавляет.
	2.9 Поразрядные операции
		Имеется шесть битовых(поразрядных) операций:
			&   - поразрядное И.
			|    - поразрядное включающее ИЛИ.
			^    - поразрядное исключающее ИЛИ.
			<< - сдвиг влево.
			>> - сдвиг вправо.
			~   - одноместное поразрядное дополнение до еденицы
		Эти операции применимы только к целочисленным аргументам:
			char, short, int, long.
	2.10 Операции с присваиванием и выражения с ними
		Укороченные версии операторов присваивания
```c
i = i + 2;
i += 2;
```
-
	2.11 Условные выражения
		Тернарный оператор:
```c
if (a > b)
{
	z = a;
}
else
{
	z = b;
}

z = (a > b) ? a : b;
```
-
	2.12 Приоритет и порядок вычисления
		Таблиаца приоритета и ассоциирования операция.
**Глава 3** Управляющие конструкции
	3.1. Операторы и блоки
		В языке С точка с запятой является элементов оператора и его завершающейся частью, а не разделительным опреаторм, как в языке Pascal.Фигурные скобки служат для группировки объявлений и операторов в составные операторы, или блоки, синтаксически эквиваленты одному оператору.
	3.2. Оператор if-else
		Нужно следить за неоднозначностю опреаторов и желательно всегда ставить скобки, чтобы не вызыватьдвухсмысленность.
```c
if (n > 2)
{
	a = n;
}
else {
	a = 0;
}
```
-
	3.3. Конструкция else-if
		Проверка условий идет сверху вниз, как только одно условие выполнилось, цепочка прирывается.
```c
int binsearch(int x, int v[], int n)
{
	int low, high, mid;
	
	low = 0;
	high = n -1;
	while (low <= high)
	{
		mid = (low+high) / 2;
		if (x < v[mid])
		{
			high = mid - 1;
		}
		else if (x > v[mid])
		{
			low = mid + 1;
		}
		else
		{
			return mid;
		}
	}

	return -1;
}
```
-
	3.4. Оператор switch
		Стоит избегать сквозного выполения switch case.
```c
switch (c)
{
	case: '0': case '1':
		puts("number);
		break;
	case ' ':
		puts("space");
		break;
	default:
		break;
}
```
-
	3.5. Циклы - while и for
```c
while (/* выражение */)
{
	/* оператор */
}

for (/* выражение1 */; /* выражени2 */; /* выражение3*/)
{
	/* оператор */
}
```
-
		В выражениях в цикле for следет избегать других операций, кроме управления самим циклом for.
			Операцию "запятая" следует использовать как можно реже и с
		осторожностью. Наиболее уместно ее применение в конструкциях, где объединяются в единое целое связанные друг с другом операции, как, например, в теле цикла for в функции reverse, или в макросах, где многошаговые вычисления объединяются в одну операцию. Запятую вполне можно применить при обмене местами элементов в функции reverse, поскольку этот обмен можно представить себе единой операцией.
	3.6. Циклы - do-while
		Проверка условия в конце - значит тело цикла точно выполнится один раз.
```c
do
{
	/* оператор */
}
while (/*выражение*/)
```
-
	3.7. Операторы break и continue
		break - завершает работу цикла и switch.
		continue - переходит к следующей итерации.
	3.8. Оператор goto и метки
```c
for (i = 0; i < n; ++n)
{
	for (j = 0; j < m; ++j)
	{
		if (a[i] == b[j])
		{
			goto found;
		}
	}
}

found:
	/* какие-то действия */
```

**Глава 4** Функции и структура программы
	4.1. Основы создания функций
		Функции могут принимать любое количество аргументов, но возвращать только одно значние или не возврашать ничего.
	4.2. Функции, возвращающие нецелые значения
		Нужно в коде явно показать, что функция возвращает другое знчение, иначе компилятор увидит эту функцию первый раз и сделает ее объвление без аргументов с возвращаемым значением int(по дефолту).
```c
int main()
{
	char line[MAX_LINE] = "123.654";
	double sum, atof(char []);

	sum += atof(line);
}
```
-
	4.3. Внешние переменные
		Внешние переменные имеют глобальную область видимости, они предоставляют собой способ обмена данными между функциями.
	4.4. Область действия
		Локальные переменные виды только внутри функций.
		Внешние переменные видны везде, но стоит учитвать, что переменные видны тфункциям, которые находятся ниже них. Чтобы дать доступ и верхним функциям нужно добавить слово extern(только объявляет переменную, то не определяет.) Чтобы получить доступ к переменной из другого файла нужно в начале этого файла объявить эту переменную.
	4.5. Заголовочные файлы
		![[Pasted image 20250803030121.png]]
	4.6. Статические переменные
			Ключевое слово static ограничивает область видимости этой внешней
		переменной/функции от точки объявления до конца этого файла.
			Ключвое слово static для локальной переменной работает по
		другому: статические внутренние переменные продолжают существовать непрерывно, а не создаются и уничтожаются при вызове и завершении функции.
	4.7. Регистровые переменные
			Объявление переменной с ключевым слово register сообщает
		компилятору, что соотвутсвующая переменная будет интунсивно использоваться программой. Как бы говорим, что эту переменную можно поместить в регистр процессора для быстрой работой с ней, но компилятор имеет право игнорировать эту информацию. От лишних объявлений переменной с ключевым слово register не бывает никакого вреда, посколько избыточные или неразрешенные обхвляения просто игнорируются компилятором.
			НО не разрешается вычислять адрес регистровой переменной,
		независимо от того, помещена ли она на самом деле в регистр процессора.
		Конкретные ограничения на количество и три регистровых переменных зависят от системы и аппаратного обеспечения.
	4.8. Блочная структура
		Язык С не является полноценнм блочно-структурным.
		Но в нем есть объявление и использование локальных переменных в жтом блоке кода, например объявленная переменная в if будет действовать только в этом блоке до закрытия фигруной скобки и так со всеми операторами.
	4.9 Инициализация
			При отсутствие явной инициализации внешние и стаические переменные
		гарантированно инициализируются нулями, а автоматические и регистровые получают неопредленные начальные значения(мусор).
			Скалярные переменные можно инициализировать прямо при
		объявлении, поставив после имени знак равенства и выражение.
			Инициалиазирующие выражения для внещних и статических
		переменных должны быть константными(инициализация выполняется один раз, фактически до начала выполнения программы). А для автоматических и регистровых переменных инициализация выполняется каждый раз при входе в соответствующий блок.
	4.10 Рекурсия
		Рекурсия - функция вызывает сама себя.
	4.11 Препроцессор С
				Первый этап компиляции - препроцессоринг.
			Два наиболее часто используемых - это директива \#include, включающая все содержимое заданнго файла в компилируемый код, и директива \#define, заменяющая некий индетификатор заданной последовательностью символов.
		4.11.1 Включение файлов
			С помощью включения файлов можно легко распоряжаться набором директив \#define и объявлений(среди прочего).
```c
#include "file_name"
#include <file_name>
```
-
			При обработке текста строка заменяется содержимым файла имя_файла. Если указано в кавычках, то поиск начинается с того места, где находится исходный текст программы. Если его там нет или имя файла заключено в угловые скобки, то поиск файла продлжается по праивлам зависящим от реализации языка.
		4.11.2. Макроподстановки
			Эта конструкция задает макроопределение или макрос:
```c
#define имя текст-для-замены
#define max(A, B)  ((A) > (B) ? (A) : (B))

#ubdef max /* отменяет определение имени */

#define dprint(expr) printf(#expr " = %g\n", expr)
/* dprint(x/y)
   printf("x/y" " = %g/n", x/y);*/

#define paste (front, back) front ## back
/* Выражение рaste (name, 1) порождает идентификатор пате 1. */
```
-
			Можно так же определить макрос с аргументами.
				Макросы очень опасны, есть много ловушек, но все же они
			бывают очень полезными.
				Если в текте водстновки перед именем формального параметра
			стоит значок #, то эта комбинация заменяется строкой в кавычках, в которые вместо формального параметра подставляется аргумент.
				Операция препроцессора ## предоставляет возможность сцепить
			фактические аргу-менты в одну строку в процессе раскрытия макроса. Если параметр в подставляемом тексте находится рядом со знаком ##, этот параметр заменяется фактическим аргумен-том, сам знак ## и окружающие его пробелы удаляются, а результат снова анализируется препроцессором.
				Правила использования вложенных знаков ## загадочны и
			малопонятны.	
		4.11.3 Условное включение
				Дают возможность управлять самой препроцесорной обработкой. Это делет возможным условное включение фрагментов кода в
					программу в зависимости от условий, выполняющихся в омент компиляции.
			Директивы \#if, \#elif, \#else - работают как обычные операторы.
			В следующем фрагменте кода анализируется имя SYSTEМ и принимается решение, какую версию заголовочного файла включать в программу:
```c
#if SYSTEM == SYSV
	#define HDR "sysv.h"
#elif SYSTEM == BSD
	#define HDR "bsd.h"
#elif SYSTEM MSDOS ==
	#define HDR "msdos.h"
#else
	#define HDR "default.h"
#endif
#include HDR
```
-
			Директивы \#ifdef u \#ifndef — это специальные формы условной директивы для проверки того, определено то или иное имя или нет. Первый пример директивы \#if, приведенный в начале раздела, можно было бы записать так:
```c
#ifndef HDR
#define HDR
/* здесь находится содержимое файла hdr.h */
#endif
```
-
**Глава 5** Указатели и массивы
	Указатель - это переменная, содержащая адрес другой переменной.
	5.1. Указатели и адреса
		Одноместная (унарная) операция & дает адрес объекта.
```c
p = &c; /* в p хранится адрес переменной c*/
```
-
		Или p укзывает на c.
			Операция & применима только к объектам, хранящимся в оперативной
		памяти: переменным и элементам массивов. Ее нельзя применить к выражениям, константным и регистровым переменным.
		Одноместная операция * называется операцией ссылки по указателю(indirection) или разыменованием (dereferencing). Применяя ее к указателю, получаем объект, на который он указывает.
```c
int x = 1, y = 2, z [10];
int *ip;        /* ip указатель на int */

ip = &x;        /* ір теперь указывает на х */
y = *ip;        /* у теперь равно 1 */
*ip = 0;        /* х теперь равно 0 */
ip = &z [0];    /* ір теперь указывает на z [0] */

double *dp, atof (char *);

iq = ip;
```
-
			Исключение является указатель на void, в котором может содержаться
		произвольный адрес без указания на тип данных, однако по указателю этого типа нельзя ссылаться и получать значения.
			Однометные операции * и &  имеют более высокий приоритет для своих
		операндов, чем арифметические операции.
		Указатели можно употреблять сами по себе, без разыменования.
	5.2. Указатели и аргументы функций
		Аргументы в функции передаются по значению, поэтому изменяются их копии. Чтобы это функция могла изменять сами объекты, нужно передать адрес, а функция принимает указатель.
```c
void swap (int *px, int *py) /* обмен местами *рх и *ру */
{
	int temp;
	
	temp = *px;
	*px = *py;
	*py = temp;
}
```
-
		![[Pasted image 20250803062106.png]]
	5.3. Указатели и массивы
		Любую операцию, выплняемую с помощью индексации массива, можно проделать с применением указателей, причем код с применением указателей обычно работает быстрее, но для непосвященных выглядит более запутанно.
```c
int a[10];
/*переменная 'a' всего лишь хранит адрес на нулевой элемент массива, а не на весь массив*/
*a /* поэтому такая операция выведет нулевой элемент массива*/
a[i] == *(a+i) /* или тоже тождественны */ &a[i] == a+i 
```
-
			Отсюда можно сказать, что выражение в виде обращения к массиву по
		индексу эквивалентно ссылке по указателю со смещением.
			Однако есть и одно различие между именем массива и указателем.
		Указатель является переенной, так что выражение pa=a и pa++ допустимы. А вот конструкции наподобие a=pa и a++ не разрешены. (где pa = &a)
		Если в функцию передать имя массива, по сути туда поступает адрес первого элемента. В вызванной функции этот аргумент является локальной переменной, так что имя массива в виде параметра функции - это указатель, т.е. переменная, содержащая адрес.
```c
/* например */
int strlen(char *s)
{
	int n;
	
	for (n = 0; *s != '\0'; s++) {
		n++;
	}

	return n;
}

/* вызов */
strlen("hello, world");
strlen(array);
strlen(ptr);

/* Следующие две форму эквиваленты, если употреблять в виде формальных параметров функции: */
char s[];
char *s;

/* Вторая форма предпочтительнее, потому что онаболее явно выражает тот факт, что параметр является укзателем. Когда в функцию передается имя массива, функция имеет право сама решать, обходиться с ним как с массивом или как с указатлем. Если это удобно и не портит удобочитаемость, можно даже комбинировать оба способа */
/* так же можно передать только часть массива */
f(&a[2])
f(a+2)
/* так же можно индексировать массив в противоположном направлении, если есть уверенность, что там есть массив */
```
-
	5.4. Адресная арифметика
		К числу разрешенных операций с указателями относятся:
			1) Присваивание указатлей одного типа
			2) Сложение или вычитание укзателя и целого числа
			3) Вычитание или сравнение указатлей, указывающих на один и тот же массив данных
			4) Присваивание нуля или сравнение с ним
			Любые другие операции с адресами являются ошибками и неразрешены.
			Нельяза складывать два указателя, умножать, делить, сдвигать или прменять маски к указателям, прибавлять к ним числа типа float или  double. За исключением указатлей тива void * нельзя даже присвоить указатель одного типа указателю другого без явного приведения типов.
	5.5. Символьные указатели и функции
		Во внутреннем представлении строки она заканчивается нулевым символом '\0', чтобы программа могла найти ее конец(значит длина строки на один символ больше).
		Обращение к строковой константе выполняется по указателю на ее первый элемент.
```c
char *pmessage;
/* Тогда следующий оператор присваивает ей указатель на массив символов */
pmessage = "now is the time";
/* При этом не выполняется копирование строки */
```
-
		В языке С нет операций для манипулирования именно строкой символов как единым целым, вместо этого применяются операции с указателями.
```c
char amessage[] = "now is the time";  /* массив */
char *pmessage = "now is the time"    /* указатель */
```
-
		В первом из них amessage - это массив, ровно такой длины, чтобы в него поместилась инициализирующая строка символов и завершающий '\0'. Отдельные символы в строке можно изменить, но переменная amessage всегда будет указывать на один и тот же участок памяти.
		А вот pmessage -  это указатель, который после инициализации указывает на строковую константу, впоследвствии этот указатель можно изменить так, чтобы он указывал в другое место, но попытка изменить содержимое строки после этого даст неопредленный результат.
	5.6. Массивы указателей и указатели на указатели
		Поскольку указатели сами по себе являются переменныыми, их можно хранить в массивах, как и переменные других типов.
```c
char *lineptr[MAXLINES]; /* Статический массив указателей на строки(выделяется на стеке или глобально) */
```
-
	5.7. Многомерные массивы
```c
char daytab[i][j]; /* [строка][столбец] */

/* Передача в функцию двумерного массива */
f(char daytab[2][13]) { }
f(char daytab[][13]) { }
f(char (*daytab)[13]) { } /* Без скобок это было бы оъявление массива из 13 указателей на данные типа char */
/* При передачи двумерного массива в функцию количество строк не имеет значения */
```
-
	5.8. Инициализация массивов указателей
```c
static char *name[] = {
	"Illegal month",
	"January", "February", "March",
	"April", "May", "June",
	"July", "August", "September",
	"October", "November", "December"
};
```
-
	5.9. Указатели и многомерные массивы
		Не стоит путать двмерные массивы и массивы указателей.
```c
int a[10][20];
int *b[10];

/* a[3][4] и b[3][4] - законное обрещение к одному элементу данных типа int */
```
-
			При этом a - полноправный двумерный массив, для него выделено 200
		ячеек памяти размера int, и для поиска элемента a\[строка]\[столбец] используется перевод координат прямоугольного массива в линейный адрес по формуле 20 x строка + столбец.
			А вот для переменной b - ее определение всего лишь выделяет память
		для 10 указателей без их инициализации, инициализация должна пвыполняться явным образом - статически или программно. Предполагая, что каждый элемент b действительно указывает на массив из дадцати элементов, получаем те же 200 ячеек типа int плюс десять ячеек для указатлей. Важно преимущество массива указателей состоит в том, что строки массива могут иметь различную длину, т.е. каждый элемент b не обязан указывать на вектор из 20 элементов. Одни указатели могут указывать на два элемнта, жругие - на пятьдесят, а третье - вообще ни на что.
	Наглядный пример:
		Массив указателей на строки:
			![[Pasted image 20250823222048.png]]
		Двумерный массив строк:
			![[Pasted image 20250823222104.png]]
	5.10. Аргументы командной строки
			В системных средах, поддерживающих язык C, существует способ
		передавать в программу аргументы или параметры командной стоки при запуске программы на выполение. При вызове функции main она получает два аргументы. Первый, который обычно назвают argc (от argument count - счетчик аргументов), содержит количетсво аргументов командной строки, с которыми была запущено программа. Второй, обычно под именем argv (от argument vector - вектор аргументов), указывает на массив символьных строк, содержищих сами аргуенты, - по одному в строке. Для манипулирования этими символьными строками, естественно, используется многоуровневая система указателей.
```c
int main(int argc, char *argv[]) {
	...
}
```
-
			По определению argv\[0] содержит имя, под которым запускается
		программа, поэтому argc всегда не меньше 1. Если счетчик argc равен 1, то после имени программы нет никаких аргументов командной строки. Первый необязательный аргумент хранится в argv\[1], а последний - в argv\[argc-1]. Кроме того, стандарт требует, чтобы элемент argv\[argc] был нулевым указателем.
		-
			В программанх на C в системе Unix принято, чтобы необязательные
		аргументы или ключи начинались со знака "минус". Кроме того, они могут стоять в любом порядке. Для большего удобства пользователей желетельно также, чтобы аргументы-ключи можно было комбинировать.
	5.11. Указетели на функции
		В языке C функция сама по себе не является переменной, но зато можно определить укзатели на функции, которые разрешено присваивать, хранит в массивах, передавать в функции, возвращать из функции и т.п.
```c
/* Объясвление функции, которая принимает четвернтым аргументом указатель на функцию */
void qsort(void *lineptr[], int left, int right,
		   int (*comp)(void *, void *));
/* Здесь сообщается, что comp - это укащзатель на функцию, принимабщую два аргумента типа void * и возвращающую числа типа int */
/* Испольщваоние comp в функции согласовано с объявлением */
if ((*comp)(v[i], v[left]) < 0)
/* Поскольку comp - указатель на функцию, то *comp - это сама функция, а вызов ее выполняется соответсвенное таким образом */
(*comp)(v[i], v[left])
/* Кргулые скобки нужны для установления правильных связей между компонентами выржения, без них получилось бы объявление функции, возвращающей указатель на int, т.е. нечто совершенно другое */
int *comp(void *, void *) /* В данном случае это непраивльно */

/* Передача в функцию указатель на функцию (вызов верхней функции)*/
qsort((void **) lineptr, 0, nlines-1,
	(int (*)(void*, void*))(numeric ? numcmp : strcmp));
/* При вызове функции qsort имена strcmp и numcmp являются указателями */

/* Тут происходит приведение указателя функции к другому типу, напмриер */
int my_func(char *, char *);
int (*p)(char*, char*) = my_func;
int (*pv)(void*, void*) = (int (*)(void*, void*)) my_func;
```
-
		Поскольку это функции, знак & перед ними не нужен, точно так де , как он не был нужен перед именами массивов.\
		Любой указатель можно привести к типу void * и обратно без  потери информации. Фактически внутренее представление данных редко зависит от наличия такого приведения, но все же лучше убдеить компилятор, что в вызове все правильно.
	5.12. Сложные объвления
			Язык C иногда обвиняют в чрезмерно сложном синтексесе объявлений - в
		частности, тех, в которых участвуют указатели на функции. Синтаксис языка построен так, чтобы объявление и использование переенных были максимально согласованы. Для простых случаев это получается вполне удачно, а вот длясложных может возникнуть путаница, поскольку объявления не всегда читаются слева направо, да еще и бывают перегружены скобками.
		![[Pasted image 20250827173034.png]]
		
**Глава 6** Структуры
		Структура - это совокупность нескольних переменных, часто различных типов,
	сгруппированных под единым именем для удобства обращения. Например список работников какго-нибудь предприятия: в нем каждый сотрудник описывается набором таких атрибутов, как имя, адрес, номер полиса социального страхования, размер зарплаты и т.д. Некоторые из этих атрибутов сами могут быть структурами: напрмиер, имя состоит из нескольких компонентов, как адрес, и даже зарплата. Еще один приер, более типичный для C, взят из компьютерной графики: точка описывается парой координат, прямоугольник - парой точек и т.д.
	-
	6.1. Основы работы со структурами
```c
struct point {
	int x;
	int y;
}
```
-
			Ключевым словом struct начинается объявление структуры, состоящей из
		списка объявлений элементов в фигурных скобках. 
			После слова struct может стоять необязательный индентификатор,
		именуемый меткой структуры. Метка обозначает конкретный структурный тип; впоследствии ее можно использовать для краткости, опуская все, что находится в скобках при объявлении структур того же вида.
			Переменные, перчисленные в объявлении структуры, называются ее
		членами, элементами или полями. Элемент структуры или ее метка может иметь то же имя, что и обыкновенная переменная (не поле структуры) безо всякого конфликта, поскольку они всегда отличаются по контексту. Более того, в разных структурах можно использовать одни и то же имена элементов, хотя с точик зрения хорошего стиля так можно делать того тогда, когда речь идет о близкородственных объектах.
			Объявление со словом struct фактически вводит новый тип данных. После правой скобки, завершающей список жлементов, может стоять список переменных, как и после имени любого элементарного типа.
Продолжение - 5.12
cтраница 133

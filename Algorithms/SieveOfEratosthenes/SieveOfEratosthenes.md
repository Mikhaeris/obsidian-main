Решето Эратосфена - это алгоритм позволяющий найти все простые числа в отрезке от 1 до N за O(N\*log(logN)) операций.

Идея: последовательно берем простые числа и вычеркиваем все кратные им.

Time Complexity: O(N\*log(logN))
Space Complexity: O(N)

Алгоритм:
```cpp
int n = 20;
vector<char> prime (n+1, true);
prime[0] = prime[1] = false;

for (int i = 2; i <= n; ++i) {
	if (prime[i]) {
		if (i*1ll*i <= n) {
			for (int j = i*i; j <= n; j += i) {
				prime[j] = false;
			}
		}
	}
}
```
Объяснение:
	Сначала помечает все числа, кроме 0 и 1, как простые. Далее следует процесс отсеивания составных чисел. В цикле перебираются все числа от 2 до N. Если текущее число простое, то все числа, которые кратны ему помечаются как составные. 
	-
	При этом нужно идти от i^2, так как все меньшие числа кратные i, обязательно имеют простой делитель мнеьше i, следовательно они уже были отсеяны раньше.
	(i^2 легко может переполнить int, в коде перед вторым вложенным циклом делается проверка с использованием типа long long).

Оптимизации:
Просеивание простыми до корня:
```cpp
int n = 20;
vector<char> prime(n+1, true);
prime[0] = prime[1] = false;

for (long long i = 2; i*i <= n; ++i) {
    if (prime[i]) {
        for (long long j = i*i; j <= n; j += i) {
            prime[j] = false;
        }
    }
}
```
Объяснение:
	Самый очевидный момент — что для того, чтобы найти все простые до n, достаточно выполнить просеивание только простыми, не превосходящими корня из n.
	На асимптотику данная оптимизация не влияет, но число операций заметно уменьшится.

Решето только по нечетным числам:
```cpp
if (n < 2) return;
int size = (n - 1) / 2;
vector<char> prime(size, true);

for (int i = 0; i < size; ++i) {
	if (prime[i]) {
		int p = 2*i + 3;
		if (p * 1ll * p > n) break;
		for (long long j = (p*1ll*p - 3)/2; j < size; j += p) {
			prime[j] = false;
		}
	}
}
```
Объяснение:
	Поскольку все чётные числа, кроме 2 — составные, то можно вообще не обрабатывать никак чётные числа, а оперировать только нечётными числами.
	-
	Во-первых, это позволит вдвое сократить объём требуемой памяти.
	Во-вторых, это уменьшит число делаемых алгоритмом операций примерно вдвое.
	-
	Так как в массиве хранятся только нечетные числа, то для перевода из нечетного индексирования в десятичное используется формула - 2\*i+3. При проходе по полученному массиву стоит это учитывать

Credits: http://e-maxx.ru/algo/eratosthenes_sieve


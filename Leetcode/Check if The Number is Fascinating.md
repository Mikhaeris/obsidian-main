**Complexity:** Easy
Answer:
	Time Complexity: O(N)
	Space Complexity: O(N)
Code:
Solution:
```cpp
class MyQueue {
public:
	MyQueue() {}
	
	void push(int x) {
		write.push(x);
	}
	
	int pop() {
		peek();
		  
		int ans = read.top();
		read.pop();
		  
		return ans;
	}
	
	int peek() {
		if (read.empty()) {
			while (!write.empty()) {
				read.push(write.top());
				write.pop();
			}
		}
		return read.top();
	}
	
	bool empty() {
		return write.empty() && read.empty();
	}
	  
private:
	stack<int> write, read;
};
```
**Explanation:**
	Цель: Требуется реализовать очередь с помощью двух стеков.
	Решение: Сделать два стека - один на запись, другой на чтение. Амортизирующий алгоритм, в котором запись, чтение и удаление происходит за O(1) - в лучшем случае, но иногда будет происходить перенос элементов из одого стека в другой и станет O(n). Это происходит из свойства очереди, если елемент попал в очередь, то он будет выводится или удаляться, когда окажется в конце. Поэтому, если добавить несколько элементов, а потом посмотреть какой элемет находитя в начале, то все элементы из записаи перейдут в чтение и доступ к ним станет за O(1), если добавить еще элементы в очередь, то они добавляются в стек для записи. Чтобы теперь получить доступ к последенему элементу: сначала будут удаляться все элементы из стека для чтения, когда стек опустеет, то элементы из записи перейдут в чтение и будут выводится до последнего элемента.
	P.S. Довольно странная задача, но на самом деле важная концепция, которую стоит понять.